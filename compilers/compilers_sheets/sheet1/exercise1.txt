One NFA that corresponds to this specification has the form of a tree, with initial state equal to the tree root, with one branch for each word in the language, and one branch specifically for identifiers. This structure works exactly the same for words that share a common prefix (as states are allowed to have multiple outgoing edges labelled with the same character).
One DFA that corresponds to this specification has the form of a tree where each node corresponds to a prefix of one string in the language, and where a string will always lead to the node corresponding to the prefix which matches the string so far. The DFA is also equipped with an accepting state for identifiers, which we reach when the input string matches no identifier, yet matches [a-zA-Z]+, and a "dustbin" non-accepting state for all other characters (in the diagram I omit edges to the dustbin). This DFA implicitly contains a trie on the set of keywords.
