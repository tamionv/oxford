\section{Problem 4}
\subsection{a}

Some code with nested \texttt{if}'s.

\begin{lstlisting}[language=Pascal]
begin
    if i then
        if i then
            i := 1
        else
            i := 2
        end
    else
        if i then
            i := 3
        else
            i := 4
        end
    end
end.
\end{lstlisting}

With it's associated \texttt{Keiko} code.

\ASMEnv{
    \ASMRow{MODULE Main 0 0             }{}
    \ASMRow{IMPORT Lib 0                }{}
    \ASMRow{ENDHDR                      }{}

    \ASMRow{PROC MAIN 0 0 0             }{}
    \ASMRow{!     if i then             }{}
    \ASMRow{LDGW \_i                    }{}
    \ASMRow{CONST 0                     }{}
    \ASMRow{JNEQ L1                     }{This row and the 2 below are very inefficient}
    \ASMRow{JUMP L2                     }{}
    \ASMRow{LABEL L1                    }{}
    \ASMRow{!         if i then         }{}
    \ASMRow{LDGW \_i                    }{}
    \ASMRow{CONST 0                     }{}
    \ASMRow{JNEQ L7                     }{This row and the 2 below are very inefficient}
    \ASMRow{JUMP L8                     }{}
    \ASMRow{LABEL L7                    }{}
    \ASMRow{!             i := 1        }{}
    \ASMRow{CONST 1                     }{}
    \ASMRow{STGW \_i                    }{}
    \ASMRow{JUMP L9                     }{}
    \ASMRow{LABEL L8                    }{}
    \ASMRow{!             i := 2        }{}
    \ASMRow{CONST 2                     }{}
    \ASMRow{STGW \_i                    }{}
    \ASMRow{LABEL L9                    }{}
    \ASMRow{JUMP L3                     }{}
    \ASMRow{LABEL L2                    }{}
    \ASMRow{!         if i then         }{}
    \ASMRow{LDGW \_i                    }{}
    \ASMRow{CONST 0                     }{}
    \ASMRow{JNEQ L4                     }{This row and the 2 below very inefficient}
    \ASMRow{JUMP L5                     }{}
    \ASMRow{LABEL L4                    }{}
    \ASMRow{!             i := 3        }{}
    \ASMRow{CONST 3                     }{}
    \ASMRow{STGW \_i                    }{}
    \ASMRow{JUMP L6                     }{}
    \ASMRow{LABEL L5                    }{}
    \ASMRow{!             i := 4        }{}
    \ASMRow{CONST 4                     }{}
    \ASMRow{STGW \_i                    }{}
    \ASMRow{LABEL L6                    }{These two labels could be combined}
    \ASMRow{LABEL L3                    }{}
    \ASMRow{RETURN                      }{}
    \ASMRow{END                         }{}
}

\subsection{b}
One peephole optimiser rule that would fix the first three inefficiencies would be used would be to transform the sequence \texttt{JNEQ a; JUMP b; LABEL a} into \texttt{JEQ b}, with similar rules for all conditional jumps.\\
One rules that would fix the next last inneficiency would be to transform \texttt{LABEL a; LABEL b} into \texttt{LABEL a}, substituting \texttt{b} with \texttt{a} throughout the code.

\subsection{c}

I notice that the first issue comes from the way that we evaluate conditionals -- more precisely, rather than always inserting jumps for "true" and "false" values, it would be more efficient to make the compiler either emit a jump or simulate "fall through" in certain cases. \\
The second issue comes from the gen\_expr not having enough context to know if there is label to be place immediately after the statement we generate, and therefore sometimes places useless \texttt{LABEL}'s. Passing such labels to gen\_expr fixes this. \\
The code generated by these approaches is:

\ASMEnv{
\ASMRow{MODULE Main 0 0}{}
\ASMRow{IMPORT Lib 0}{}
\ASMRow{ENDHDR}{}
\ASMRow{PROC MAIN 0 0 0}{}
\ASMRow{!     if i then}{}
\ASMRow{LDGW \_i}{}
\ASMRow{CONST 0}{}
\ASMRow{JEQ L1}{}
\ASMRow{!         if i then}{}
\ASMRow{LDGW \_i}{}
\ASMRow{CONST 0}{}
\ASMRow{JEQ L4}{}
\ASMRow{!             i := 1}{}
\ASMRow{CONST 1}{}
\ASMRow{STGW \_i}{}
\ASMRow{JUMP L2}{}
\ASMRow{LABEL L4}{}
\ASMRow{!             i := 2}{}
\ASMRow{CONST 2}{}
\ASMRow{STGW \_i}{}
\ASMRow{JUMP L2}{}
\ASMRow{LABEL L1}{}
\ASMRow{!         if i then}{}
\ASMRow{LDGW \_i}{}
\ASMRow{CONST 0}{}
\ASMRow{JEQ L3}{}
\ASMRow{!             i := 3}{}
\ASMRow{CONST 3}{}
\ASMRow{STGW \_i}{}
\ASMRow{JUMP L2}{}
\ASMRow{LABEL L3}{}
\ASMRow{!             i := 4}{}
\ASMRow{CONST 4}{}
\ASMRow{STGW \_i}{}
\ASMRow{LABEL L2}{}
\ASMRow{RETURN}{}
\ASMRow{END}{}
\ASMRow{GLOVAR \_i 4}{}
}
Which is acceptable. \\

The code that generates this is:

\begin{lstlisting}[language=Ml]

open Tree
open Keiko

let optflag = ref false

(* |gen_expr| -- generate code for an expression *)
let rec gen_expr =
    function
        Constant x ->
            CONST x
    | Variable x ->
            SEQ [LINE x.x_line; LDGW x.x_lab]
    | Monop (w, e1) ->
            SEQ [gen_expr e1; MONOP w]
    | Binop (w, e1, e2) ->
            SEQ [gen_expr e1; gen_expr e2; BINOP w]

let logical_opposite = function
    Eq -> Neq
    | Neq -> Eq
    | Lt -> Geq
    | Geq -> Lt
    | Gt -> Leq
    | Leq -> Gt

(* gen_cond e tlab flab will generate a conditional on expression e
 * If e is true and tlab is of the form Some t, we will jump to t.
 * If e is false and flab is of the form Some f, we jump to f.
 * If e is true and tlab is of the form None, we fall through.
 * If e is false and flab is of the form None, we fall through. *)
let rec gen_cond e tlab flab =
    match (e, tlab, flab) with
        (_, None, None) -> NOP
    | (Constant x, Some t, None) -> if x <> 0 then JUMP t else NOP
    | (Constant x, None, Some f) -> if x <> 0 then NOP else JUMP f
    | (Constant x, Some t, Some f) -> if x <> 0 then JUMP t else  JUMP f
    | (Binop ((Eq|Neq|Lt|Gt|Leq|Geq) as w, e1, e2), Some t, None) -> 
            SEQ [gen_expr e1; gen_expr e2; JUMPC (w, t) ]
    | (Binop ((Eq|Neq|Lt|Gt|Leq|Geq) as w, e1, e2), None, Some f) -> 
            SEQ [gen_expr e1; gen_expr e2; JUMPC (logical_opposite w, f) ]
    | (Binop ((Eq|Neq|Lt|Gt|Leq|Geq) as w, e1, e2), Some t, Some f) -> 
            SEQ [gen_expr e1; gen_expr e2; JUMPC (w, t); JUMP f ]
    | (Monop (Not, e1), _, _)->
            gen_cond e1 flab tlab
    | (Binop (And, e1, e2), Some t, None) ->
            let lab1 = label () in
            SEQ [gen_cond e1 None (Some lab1);
                gen_cond e2 (Some t) None; LABEL lab1]
    | (Binop (And, e1, e2), None, Some f) ->
            SEQ [gen_cond e1 None (Some f); gen_cond e2 None (Some f)]
    | (Binop (And, e1, e2), Some t, Some f)->
            let lab1 = label () in
            SEQ [gen_cond e1 (Some lab1) (Some f);
                LABEL lab1; gen_cond e2 (Some t) (Some f)]
    | (Binop (Or, e1, e2), Some t, None) ->
            let lab1 = label () in
            SEQ [gen_cond e1 (Some lab1) None;
                gen_cond e2 None (Some t); LABEL lab1]
    | (Binop (Or, e1, e2), None, Some f) ->
            SEQ [gen_cond e1 (Some f) None; gen_cond e2 (Some f) None]
    | (Binop (Or, e1, e2), Some t, Some f) ->
            let lab1 = label () in
            SEQ [gen_cond e1 (Some t) (Some lab1);
                LABEL lab1; gen_cond e2 (Some t) (Some f)]
    | (_, Some t, None) -> SEQ [gen_expr e; CONST 0; JUMPC (Neq, t); ]
    | (_, None, Some f) -> SEQ [gen_expr e; CONST 0; JUMPC (Eq, f); ]
    | (_, Some t, Some f) ->
            SEQ [gen_expr e; CONST 0; JUMPC (Neq, t); JUMP f]


(* gen_stmt final_lab s will generate code for a statement s
 * If final_lab is of the form Some lab, we will assume that
 * immediately following the code generated by s there exists
 * some label lab.
 * Otherwise, we have no such assumption *)
let rec gen_stmt final_lab s =
    match (s, final_lab)with
      (Skip, _) -> NOP
    | (Seq stmts, _) -> SEQ ((List.map (gen_stmt None)
        (List.rev (List.tl (List.rev stmts))))
        @ [gen_stmt final_lab (List.hd (List.rev stmts))])
    | (Assign (v, e), _)->
            SEQ [LINE v.x_line; gen_expr e; STGW v.x_lab]
    | (Print e, _)->
            SEQ [gen_expr e; CONST 0; GLOBAL "lib.print"; PCALL 1]
    | (Newline, _)->
            SEQ [CONST 0; GLOBAL "lib.newline"; PCALL 0]
    | (IfStmt (test, thenpt, elsept), Some lab)->
            let lab1 = label () in
            SEQ [gen_cond test None (Some lab1); 
                gen_stmt (Some lab) thenpt ; JUMP lab;
                LABEL lab1; gen_stmt (Some lab) elsept ]
    | (IfStmt (test, thenpt, elsept), None) ->
            let lab1 = label () and lab2 = label () in
            SEQ [gen_cond test (None) (Some lab1); 
                gen_stmt (Some lab2) thenpt ; JUMP lab2;
                LABEL lab1; gen_stmt (Some lab2) elsept ; LABEL lab2]
    | (WhileStmt (test, body), _)->
            let lab1 = label () and lab2 = label () and lab3 = label () in
            SEQ [JUMP lab2; LABEL lab1; gen_stmt (Some lab2) (body) ; 
          LABEL lab2; gen_cond test (Some lab1) (Some lab3); LABEL lab3]

(* |translate| -- generate code for the whole program *)
let translate (Program ss) =
    let code = gen_stmt None ss in
    Keiko.output (if !optflag then Peepopt.optimise code else code)
\end{lstlisting}






