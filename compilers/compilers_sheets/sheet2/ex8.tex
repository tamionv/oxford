\section{Problem 8}

An abstract syntax that would 

\begin{lstlisting}[language=Ml]
type expr = IfExpr of expr * expr * expr
\end{lstlisting}

To add this to an Ocamlyacc grammar, take the grammar from lab 1 and replace the rules for $expr$ with:
\begin{lstlisting}[language=Ml]
expr :
    IF expr THEN expr ELSE expr { IfExpr ( $2, $4, $6 ) }
    | ifless_expr               { $1 }

ifless_expr :
    simple                     { $1 }
    | ifless_expr RELOP simple { Binop ($2, $1, $3) } 

\end{lstlisting}

This way of doing things makes this \texttt{if then else} construct have the highest possible precedence (i.e. \texttt{if e then e else e + if e then e else e} is interpreted as \texttt{if e then e else (e + if e then e else e)}).

\subsection{b}

To enhance gen\_expr to deal with this, simply add the following case:

\begin{lstlisting}[language=Ml]

let rec gen_expr = (* all the previous cases *)
    | IfExpr (c, e1, e2) -> 
        let lab1 = label () and lab2 = label () and lab3 = label () in
        SEQ [gen_cond c lab1 lab2 ;
            LABEL lab1 ; gen_expr e1 ; JUMP lab3 ;
            LABEL lab2 ; gen_expr e2 ; LABEL lab3 ]
\end{lstlisting}

Also, make it so that gen\_expr and gen\_cond can mutually recurse, as follows:

\begin{lstlisting}[language=Ml]

let rec gen_expr = (* ... *)
    and gen_cond = (* ... *)

\end{lstlisting}

\subsection{c}

The code generated by this is:

\ASMEnv{
\ASMRow{LDGW \_i}{}
\ASMRow{CONST 0}{}
\ASMRow{JGEQ L4}{}
\ASMRow{JUMP L5}{}
\ASMRow{LABEL L4}{}
\ASMRow{LDGW \_a}{}
\ASMRow{LDGW \_i}{}
\ASMRow{OFFSET}{}
\ASMRow{LOADW}{}
\ASMRow{LDGW \_x}{}
\ASMRow{JGT L1}{}
\ASMRow{JUMP L6}{}
\ASMRow{LABEL L5}{}
\ASMRow{CONST 0}{}
\ASMRow{LABEL L6}{}
\ASMRow{CONST 0}{}
\ASMRow{JNEQ L1}{}
\ASMRow{JUMP L2}{}
\ASMRow{LABEL L1}{}
\ASMRow{LDGW \_i}{}
\ASMRow{CONST 1}{}
\ASMRow{PLUS}{}
\ASMRow{STGW \_i}{}
\ASMRow{JUMP L3}{}
\ASMRow{LABEL L2}{}
\ASMRow{LABEL L3}{}
}

Some rules that would partially fix this code are:

\texttt{JGT a; JUMP b ; LABEL a} $\rightarrow$ \texttt{JLT b} \textit{with similar rules for other conditional jumps, assuming that a is not used elsewhere} \\
\texttt{LABEL a; LABEL b} $\rightarrow$ \texttt{LABEL a} \textit{substituting a for b everywhere else} \\
\texttt{JUMP a; LABEL a} $\rightarrow$ \texttt{LABEL a} \\

Applying these leads to:

\ASMEnv{
\ASMRow{LDGW \_i}{}
\ASMRow{CONST 0}{}
\ASMRow{JLT L5}{}
\ASMRow{LDGW \_a}{}
\ASMRow{LDGW \_i}{}
\ASMRow{OFFSET}{}
\ASMRow{LOADW}{}
\ASMRow{LDGW \_x}{}
\ASMRow{JGT L1}{}
\ASMRow{JUMP L6}{}
\ASMRow{LABEL L5}{}
\ASMRow{CONST 0}{}
\ASMRow{LABEL L6}{}
\ASMRow{CONST 0}{}
\ASMRow{JNEQ L1}{}
\ASMRow{JUMP L3}{}
\ASMRow{LABEL L1}{}
\ASMRow{LDGW \_i}{}
\ASMRow{CONST 1}{}
\ASMRow{PLUS}{}
\ASMRow{STGW \_i}{}
\ASMRow{LABEL L3}{}
}

This is still not quite as good as the code generated by the native and, as this code still has an annoying comparison to $0$ (as a conditional on an if expression first evaluates the expression then compares the result to $0$). I am not sure how to fix this.
