\documentclass[a4paper,10pt]{article}
\usepackage{inconsolata}
\usepackage{hyperref}
\usepackage{hhline}
\usepackage[T1]{fontenc} 
\usepackage[utf8]{inputenc}
\usepackage{helvet}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{tabularx}
\usepackage[margin=0.5in]{geometry}
\usepackage{multicol}

\usepackage{amsmath,amssymb,amsthm} 
\setlength\parindent{0pt}
\renewcommand{\familydefault}{\sfdefault}

\title{Compilers: practical assignment report}
\author{Candidate \#: 1023505}
\date{\today}

\lstdefinestyle{tvnstyle}{
    frame=single,
    backgroundcolor=\color{white},   
    commentstyle=\color{gray},
    keywordstyle=\color{purple},
    numberstyle=\color{blue},
    stringstyle=\color{red},
    basicstyle=\ttfamily\small,
    xleftmargin=.25in,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=none,
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstdefinestyle{teststyle}{
    frame=none,
    backgroundcolor=\color{white},   
    commentstyle=\color{darkgray},
    keywordstyle=\color{purple},
    numberstyle=\color{blue},
    stringstyle=\color{red},
    basicstyle=\ttfamily\small,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=none,
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    morecomment=[f][\color{gray}]@,
}

\newcommand{\lstbg}[3][0pt]{{\fboxsep#1\colorbox{#2}{\strut #3}}}
\lstdefinelanguage{diff}{
     morecomment=[f][\lstbg{red!20}]-,
     morecomment=[f][\lstbg{green!20}]+,
     morecomment=[f][\textit]{diff},
     morecomment=[f][\textit]{---},
     morecomment=[f][\textit]{+++},
     morecomment=[f][\lstbg{darkgray!20}]{diff},
     morecomment=[f][\lstbg{darkgray!20}]{+++},
     morecomment=[f][\lstbg{darkgray!20}]{---},
     morecomment=[f][\textit]{@@},
}

\newcommand{\includetest}[1]{
    \subsection{\textbf{\texttt{\verb|#1|}}}
    \lstinputlisting[language=pascal]{lab4/test/#1}
}

\lstdefinestyle{pascal}{
    style=teststyle,
    morekeywords={proc,continue},
}

\begin{document}

\lstset{style=tvnstyle}

\maketitle

\section{Task}
The task requires us to add \texttt{continue} statements and call by name semantics to the compiler given in lab 4. This report contains both a description of the changes made, as well as the tests added to test these features. Appendix A shows a full automatically generated summary of the changes made, and Appendix B contains the full text of the tests, including the output each test should generate when run, and the output generated by the compiler for these tests. A table of contents can be found at the end.

\section{Continue statements}
Adding \texttt{continue} statements to the language requires considering several aspects of the compiler: the lexer, the abstract syntax tree, the parser, the semantic analyser, the intermediate code generator and the machine code generator. The changes to these aspects, as well as the new tests added, are described below.

\subsection{Lexical analysis}
To modify the lexer for our purposes, add a corresponding symbol to \texttt{symtable}, in \texttt{lexer.mll}, as follows:

\begin{lstlisting}[language=ml]
let symtable = 
  Util.make_hash 100
    [ ("continue", CONTINUE); (* all old symbols *) ]
\end{lstlisting}

\subsection{Abstract syntax}
To modify the abstract syntax for our purposes, add a new constructor \texttt{ContinueStmt} to the type \texttt{stmt\_guts}, in \texttt{tree.ml} and \texttt{tree.mli}, as follows:

\begin{lstlisting}[language=ml]
and stmt_guts =
  (* all the old constructors *)
  | ContinueStmt
\end{lstlisting}

Also, modify \texttt{fStmt} to accept \texttt{ContinueStmt}'s:

\begin{lstlisting}[language=ml]
and fStmt s = 
  match s.s_guts with
    (* all old cases *)
    | ContinueStmt ->
        fMeta "(CONTINUE)" []
\end{lstlisting}

\subsection{Parsing}

To modify the parser in \texttt{parser.mly} to accept \texttt{continue} statements, add a new token \texttt{CONTINUE}, as follows:

\begin{lstlisting}[language=c]
%token                  CONTINUE
\end{lstlisting}

Also, add a new rule for \texttt{stmt1} that produces a \texttt{ContinueStmt}, as follows:

\begin{lstlisting}[language=c]
stmt1 :
  /* all the old rules */
  | CONTINUE                            { ContinueStmt } ;
\end{lstlisting}

\subsection{Semantic analysis}
Several modifications must be made to the semantic analyser from \texttt{check.ml}, to make the compiler produce a semantic error for \texttt{Continue} statements that are not within loops:
\begin{itemize}
    \item Add a reference to a boolean called \texttt{in\_loop}, in the scope of \texttt{check\_stmt}, that will be made to contain \texttt{true} if and only if the statement we are currently checking is inside a loop:
\begin{lstlisting}[language=ml]
let rec in_loop = ref false
and check_stmt s env alloc = (*...*)
\end{lstlisting}

\item To check \texttt{while}, \texttt{repeat} and \texttt{for} statements, add code to \texttt{check\_stmt} that modifies \texttt{in\_loop} before and after the pre-existing code, to make sure that \texttt{in\_loop} continues to have the property mentioned in the previous bullet point:
\begin{lstlisting}[language=ml]
and check_stmt s env alloc =
  err_line := s.s_line;
  match s.s_guts with
    (* Other cases, such as Skip, Seq ss, etc. *)
    | (*While/Repeat/For*)Stmt (*Parameters*) ->
        let old_in_loop_value = !in_loop in
        in_loop := true;
        (* Old code *)
        in_loop := old_in_loop_value
\end{lstlisting}
\item To check \texttt{continue} statements, if \texttt{in\_loop} contains \texttt{false}, raise an appropriate semantic error:
\begin{lstlisting}[language=ml]
and check_stmt s env alloc =
  err_line := s.s_line;
  match s.s_guts with
    (* Other cases *)
     | ContinueStmt ->
        if not !in_loop
        then sem_error "continue statement must be in a loop" []
        else ()
\end{lstlisting}
\end{itemize}

\subsection{Intermediate code generation}
To generate intermediate code for  \texttt{continue} statements, we store the place in the intermediate code to which a \texttt{continue} statement should jump. The changes made, which follow, are in service to this design:
\begin{itemize}
    \item First, we add \texttt{continue\_lab}, a reference to the label to which a \texttt{continue} statement should jump, in the scope of \texttt{gen\_stmt}:
\begin{lstlisting}[language=ml]
let rec continue_lab = ref (label ())
and gen_stmt s = 
\end{lstlisting}
    \item The code in \texttt{gen\_stmt} that generates \texttt{while} statements must remember the previous value for \texttt{continue\_lab}, reassign \texttt{continue\_lab} appropriately, generate code for the \texttt{while} statement (storing the result in \texttt{return\_value}), restore the old value of \texttt{continue\_lab}, then return the stored code:
\begin{lstlisting}[language=ml]
and gen_stmt s = 
    (* Other cases *)
      | WhileStmt (test, body) ->
          (* The test is at the top, improving the chances of finding
             common subexpressions between the test and loop body. *)
          let l1 = label () and l2 = label () and l3 = label()
          and old_continue_lab = !continue_lab in
          continue_lab := l1;
          let return_value = 
              <SEQ,
                <LABEL l1>,
                gen_cond test l2 l3,
                <LABEL l2>,
                gen_stmt body,
                <JUMP l1>,
                <LABEL l3>> in
          continue_lab := old_continue_lab;
          return_value
\end{lstlisting}
    \item I add an extra label \footnote{This does not increase code length if there are no \texttt{Continue} statements in the loop, since in that case the label added will have no \texttt{JUMP}'s to it, and thus can be optimised away during peephole optimisation}  in the intermediate code generated for \texttt{repeat} statements, immediately before the code that tests the loop condition; this is jumped to by \texttt{continue} statements in this loop. I also modify \texttt{continue\_lab} before and after code generation as with \texttt{while} statements:
\begin{lstlisting}[language=ml]
and gen_stmt s = 
    (* Other cases *)
      | RepeatStmt (body, test) ->
          let l1 = label () and l2 = label () and l3 = label ()
          and old_continue_lab = !continue_lab in
          continue_lab := l2;
          let return_value = 
              <SEQ,
                <LABEL l1>,
                gen_stmt body, 
                <LABEL l2>,
                gen_cond test l3 l1,
                <LABEL l3>> in
          continue_lab := old_continue_lab;
          return_value
\end{lstlisting}
    \item \texttt{for} statements are modified very similarly to \texttt{repeat} statements:
\begin{lstlisting}[language=ml]
and gen_stmt s = 
    (* Other cases *)
      | ForStmt (var, lo, hi, body, upb) ->
          (* Use previously allocated temp variable to store upper bound.
             We could avoid this if the upper bound is constant. *)
          let tmp = match !upb with Some d -> d | _ -> failwith "for" in
          let l1 = label () and l2 = label () and l3 = label ()
          and old_continue_lab = !continue_lab in
          continue_lab := l2;
          let return_value =
              <SEQ,
                <STOREW, gen_expr lo, gen_addr var>,
                <STOREW, gen_expr hi, address tmp>,
                <LABEL l1>,
                <JUMPC (Gt, l3), gen_expr var, <LOADW, address tmp>>,
                gen_stmt body,
                <LABEL l2>,
                <STOREW,
                    <BINOP Plus, gen_expr var, <CONST 1>>, gen_addr var>,
                <JUMP l1>,
                <LABEL l3>> in
          continue_lab := old_continue_lab;
          return_value
\end{lstlisting}
    \item \texttt{continue} statements are translated directly into \texttt{JUMP}'s to \texttt{!continue\_lab}:
\begin{lstlisting}[language=ml]
and gen_stmt s = 
    (* Other cases *)
      | ContinueStmt -> <JUMP !continue_lab>
\end{lstlisting}
\end{itemize}
\subsection{Machine code generation}
The pre-existing machine code generator is sufficient to generate correct code, and the code it generates is reasonably clean; the tests I created reveal no obvious inefficiencies, and most of the old tests now generate the same code, ignoring differences in label names, on optimisation level \texttt{-O2}.
\subsection{Testing}
All previous tests continue to pass; additionally, I have added 6 new tests (which pass): \\
\begin{tabularx}{\linewidth}{ |X|X| }
\hline
    \textbf{Test name} & \textbf{Test function} \\
\hhline{|=|=|}
    \texttt{while\_continue.p} & Tests a \texttt{continue} statement inside a \texttt{while} loop. \\
\hline
    \texttt{repeat\_continue.p} & Tests a \texttt{continue} statement inside a \texttt{repeat} loop. \\
\hline
    \texttt{for\_continue.p} & Tests a \texttt{continue} statement inside a \texttt{for} loop. \\
\hline
    \texttt{bare\_continue.p} & Tests a \texttt{continue} statement not inside a loop \footnote{NB: this should produce an error message -- to be able to test this, I have extended the testing script in the \texttt{Makefile} so that error messages can be tested}. \\
\hline
    \texttt{multiple\_continues.p} & Tests loops that contain multiple \texttt{continue} statements. \\
\hline
    \texttt{nested\_continue.p} & Tests continue statements inside nested loops \\
\hline
\end{tabularx}

\section{Call by name semantics}
First, a preliminary note; notice the peculiarities of the following code:
\begin{lstlisting}[language=pascal, style=pascal, frame=single]
proc f(=> p : integer);
begin
    print_num(p);
    print_num(p);
    newline()
end;
proc g(var p : integer);
begin
    p := p + 1;
    return p
end;
proc h();
    var x : integer;
begin
    f(g(x) + 3)
end;
begin
    h()
end.
\end{lstlisting}

Interestingly, \texttt{f} has no way of accessing the variable \texttt{x} using only the information visible to it through it's static link or dynamic link, so it must somehow be passed this variable's address (the value is not sufficient, because \texttt{g} changes the value of \texttt{x}). Rather than exhaustively passing the address of each variable mentioned in an argument directly, which might take very much stack space, and is quite complicated, it makes more sense to simply wrap each call by name parameter in a thunk (i.e. a procedure created implicitly by the compiler), and pass that. In this design, the code in the example should compile to essentially the same intermediate code as:

\begin{lstlisting}[language=pascal, style=pascal, frame=single]
proc f(proc p(): integer): integer;
begin
    print_num(p());
    print_num(p());
    newline()
end;
proc g(var p : integer): integer;
begin
    p := p + 1;
    return p
end;
proc h(): integer;
    var x : integer;
    proc thunk();
    begin
        return g(x) + 3;
    end;
begin
    f(thunk)
end;
begin
    h()
end.
\end{lstlisting}
In essence, in this design a function that accepts a call by name parameter will treat that parameter precisely as though it were a function that takes no arguments and returns an \texttt{integer}; and code calling a function with such parameters will wrap the argument it passes in a thunk. \\
This deisgn will also not allow getting the address of a call by name parameter (i.e. not letting such parameters be assigned to, and not letting them be passed as call by reference parameters). This is in accordance with the specification given in the task, and does not substantially reduce functionality (as demonstrated by the test cases that implement Jensen's device and Knuth and Merner's general problem solver), since our language includes call by reference parameters. \\
I split the implementation of this feature into the same parts as before.

\subsection{Lexical analysis}
To modify the lexer for our purposes, add a new rule to \texttt{rule token}, in \texttt{lexer.mll}:
\begin{lstlisting}[language=ml]
rule token =
    (* Other rules *)
    | "=>"              { RIGHTARROW }
\end{lstlisting}

\subsection{Abstract Syntax}
We must add a new constructor \texttt{NParamDef} to the type \texttt{def\_kind}, defined in \texttt{dict.ml} and \texttt{dict.mli}:
\begin{lstlisting}[language=ml]
type def_kind = 
    (* Other constructors *)
  | NParamDef                   (* Named parameter *)
    (* Other constructors *)
\end{lstlisting}

Also, I extend \texttt{fKind} in \texttt{tree.ml} to accept \texttt{NParamDef}'s:

\begin{lstlisting}[language=ml]
and fKind =
  function
    (* Other cases *)
    | NParamDef -> fStr "NPARAM"
    (* Other cases *)
\end{lstlisting}

\subsection{Parsing}

To modify the parser from \texttt{parser.mly} to accept call by name parameters, first add a new token \texttt{RIGHTARROW}, as follows:

\begin{lstlisting}[language=c]
%token                  RIGHTARROW
\end{lstlisting}

and then add a new rule to \texttt{formal\_decl}, as follows:

\begin{lstlisting}[language=c]
formal_decl :   
    /* Other rules */
   | RIGHTARROW ident_list COLON typexpr { VarDecl (NParamDef, $2, $4) } ;
\end{lstlisting}
\subsection{Semantic Analysis}
Several changes must be made to the semantic analyser found in \texttt{check.ml}, so as to comply with the specification given in the task (which specifies several cases that should lead to errors), and to comply with the design outlined earlier:
\begin{itemize}
    \item I make \texttt{has\_value} recognise that \texttt{NParamDef}'s have values:
        \begin{lstlisting}[language=ml]
let has_value d = 
  match d.d_kind with
      ConstDef _ | VarDef | CParamDef | VParamDef | StringDef | NParamDef-> true 
    | _ -> false
        \end{lstlisting}
    \item I make \texttt{do\_alloc} recognise that \texttt{NParamDef}'s need to be allocated:
        \begin{lstlisting}[language=ml]
let do_alloc alloc ds =
  let h d =
    match d.d_kind with
        VarDef | CParamDef | VParamDef | FieldDef | PParamDef | NParamDef->
          alloc d
      | _ -> () in
  List.iter h ds
        \end{lstlisting}
    \item I make \texttt{NParamDef} work precisely like \texttt{CParamDef} and \texttt{VParamDef} in \texttt{check\_arg}, since the same semantic checks must be done on call by name arguments as with call by reference or call by value arguments:
        \begin{lstlisting}[language=ml]
and check_arg formal arg env =
  match formal.d_kind with
        CParamDef | VParamDef | NParamDef-> (* Old code for CParamDef and VParamDef *)
        \end{lstlisting}
    \item I make \texttt{NParamDef} work precisely like \texttt{PParamDef} in \texttt{param\_alloc}, since a call by name parameter is implemented as a function parameter, and thus should be allocated as one:
        \begin{lstlisting}[language=ml]
let param_alloc pcount d =
  let s = param_rep.r_size in
  match d.d_kind with
    (* Other cases *)
    | PParamDef | NParamDef ->
        d.d_addr <- Local (param_base + s * !pcount);
        pcount := !pcount + 2
    (* Other cases *)
        \end{lstlisting}
    \item I modify \texttt{check\_var} to output an appropriate error message for call by name parameters.
        \begin{lstlisting}[language=ml]
let rec check_var e addressible =
  match e.e_guts with
      Variable x ->
        let d = get_def x in
        begin
          match d.d_kind with 
            (* Other cases *)
            | NParamDef ->
                sem_error "$ is a call by name parameter, and has no address" [fId x.x_name]
            (* Other cases *)
        end
    (* Other cases *)
$
        \end{lstlisting}
    \item I add functions \texttt{contains\_call\_by\_name} (which checks if a particular declaration contains a call by name parameter at any level) and \texttt{check\_param} (which, for a given declaration, checks that all call by name parameters are integers, and that no parameters are functions that take call by name parameters):
\begin{lstlisting}[language=ml]
(* This will check if it's argument, a formal parameter, contains 
 * a call by name parameter at any level *)
and contains_call_by_name d = match d with
  VarDecl(NParamDef, _, _) -> true
  | PParamDecl(Heading(_, params, _)) -> List.exists contains_call_by_name params
  | _ -> false

(* This checks if a formal parameter is acceptable *)
and check_param env d = match d with
  (* If the formal parameter is a call by name parameter
   * we check if it is of intergral type *)
  VarDecl(NParamDef, _, te) ->
    let t = check_typexpr te env in
    (
    match t.t_guts with
      BasicType IntType -> ()
      | _ -> sem_error "Call by name parameter must be an integer" []
    )
  (* If the parameter is a procedure, then we check that
   * it contains no call by name parameters at any level *)
  | PParamDecl (Heading(_, params, _)) ->
      if List.exists contains_call_by_name params
      then sem_error "Functions that use call by name parameters cannot be parameters" []
      else ()
  | _ -> ()
\end{lstlisting}
\end{itemize}
\subsection{Intermediate code generation}
Several changes must be made to \texttt{tgen.ml}, in order to comply with the design specified previously. In general, I will modify the parts of the code that consume call by name parameters to make them treat these parameters like function parameters that take no arguments and return an integer, and I will modify the parts of the code that pass call by name arguments so as to have them pass a thunk instead, simultaneously adding the thunk that needs to be produced to a global list of such thunks. Near the end of intermediate code generation, I will then build all the thunks in this global list. As these thunks may also contain function calls that use call by name parameters, and thus may also spawn new thunks of their own, it is necessary to repeatedly build all the thunks in the global list until no more are spawned, removing thunks that are already built along the way so as not to build a thunk twice. The changes made to this part of the compiler now follow:
\begin{itemize}
    \item I make \texttt{gen\_closure} work on \texttt{NParamDef}'s the same as it does on \texttt{PParamDef}'s:
        \begin{lstlisting}[language=ml]
let gen_closure d = 
  match d.d_kind with
      (* Other cases *)
    | PParamDef | NParamDef->
        (<LOADW, address d>,
          <LOADW, <OFFSET, address d, <CONST addr_size>>>)
      (* Other cases *)
        \end{lstlisting}
    \item I make \texttt{gen\_addr} generate an appropriate error (\texttt{Named parameters have no address}) when asked to generate an address for a call by name parameter.
        \begin{lstlisting}[language=ml]
(* |gen_addr| -- code for the address of a variable *)
let rec gen_addr v = 
  match v.e_guts with
      Variable x ->
        let d = get_def x in
        begin
          match d.d_kind with
            (* Other cases *)
            | NParamDef -> failwith "Named parameters have no address"
            (* Other cases *)
        end
      (* Other cases *)
        \end{lstlisting}
    \item I make \texttt{gen\_expr} treat \texttt{NParamDef}'s like function calls that take no arguments:
\begin{lstlisting}[language=ml]
and gen_expr e =
  match e.e_value with
      Some v -> 
        <CONST v>
    | None -> 
        begin
          match e.e_guts with
              Variable x when (get_def x).d_kind == NParamDef ->
                gen_call x []
              (* other cases *)
        end
\end{lstlisting}
    \item I make \texttt{gen\_call} treat \texttt{NParamDef}'s like normal procedures, with no parameters:
\begin{lstlisting}[language=ml]
and gen_call x args =
  let d = get_def x in
  match d.d_kind with
    (* Other cases *)
    | NParamDef ->
        let (fn, sl) = gen_closure d in
        <CALL 0, @(fn :: <STATLINK, sl> :: [])>
    (* Other cases *)
\end{lstlisting}
    \item I add a new counter \texttt{curr\_thunk} and an associated function \texttt{get\_thunk\_label}, which generates names for thunks. The names are of the form \texttt{\_\_thunk\_id}, where \texttt{id} is the current value of \texttt{curr\_thunk} (which shall be incremented after each call of \texttt{get\_thunk\_label}); this scheme insures that no two thunk names can coincide (due to \texttt{id}), and that a thunk's name will never coincide with a user defined function's name (since such names cannot begin with \texttt{\_\_}):
\begin{lstlisting}[language=ml]
and curr_thunk = ref 0
and get_thunk_label () = 
    curr_thunk := 1 + !curr_thunk;
    sprintf "__thunk_$" [fNum !curr_thunk]
$
\end{lstlisting}

\item I add a new global variable, \texttt{thunks\_to\_be\_generated}, a reference to an initially empty list. This will hold 3-tuples \texttt{(label, level, block)}, each of which represent that we need to generate a thunk whose name is \texttt{label}, at level \texttt{level}, whose body consists of \texttt{block}.

\item I make \texttt{gen\_arg} treat \texttt{NParamDef}'s as follows:
    \begin{enumerate}
        \item We extract the expression which is passed as a parameter.
        \item We create a block of code that corresponds to a body of a function that simply returns that expression
        \item We create an thunk name, using \texttt{get\_thunk\_label}.
        \item We push these values onto \texttt{thunks\_to\_be\_generated}, to be generated later.
        \item We generate code that pushes a closure for the function we just asked to be created onto the stack.
    \end{enumerate}
    The code follows:
\begin{lstlisting}[language=ml]
and gen_arg f a = 
  match f.d_kind with
      (* Other cases *)
    | NParamDef ->
        (
        (* To generate a call by name argument we wrap the argument expression 
         * in a block that simply returns it: *)
        let block = makeBlock ([], {s_guts = Return (Some a); s_line = -1}) in
        (* then create a label for a thunk *)
        let lab = get_thunk_label () in
        (* and add the thunk into the global list: *)
        thunks_to_be_generated := 
          (lab, !level, block) :: !thunks_to_be_generated;
        (* Now, the actual code is simply a closure for that
         * thunk *)
        [<GLOBAL lab>; <LOCAL 0>]
        )
    | _ -> failwith "bad arg"
\end{lstlisting}
    \item I add a new function \texttt{build\_all\_thunks} that will build code for all the thunks in \texttt{thunks\_to\_be\_generated}, and then, if some new thunks have been added to the \texttt{thunks\_to\_be\_generated}, will call itself recursively:
\begin{lstlisting}[language=ml]
let rec build_all_thunks () =
  (* This reverses in order to build the thunks
   * in the order they are required *)
  let tmp = List.rev !thunks_to_be_generated in
  thunks_to_be_generated := [];
  (* I build all the thunks required *)
  List.map (fun (lab, lev, bl) -> do_proc lab lev 0 bl) tmp;
  (* And check if any more are now required *)
  if (List.length !thunks_to_be_generated > 0)
    then build_all_thunks ()
    else ()
\end{lstlisting}
    \item I modify \texttt{translate} to make it call \texttt{build\_all\_thunks}:
\begin{lstlisting}[language=ml]
let translate (Prog (block, glodefs)) =
  Target.preamble ();
  gen_procs (get_decls block);
  do_proc "pmain" 0 0 block;
  build_all_thunks ();
  List.iter gen_global !glodefs;
  List.iter (fun (lab, s) -> Target.emit_string lab s) (string_table ());
  Target.postamble ()
\end{lstlisting}

\end{itemize}
\subsection{Machine code generation}
The pre-existing machine code generator is sufficient to generate correct code, and the code it generates is reasonably clean, as demonstrated by the tests that follow.
\subsection{Testing}

All previous tests continue to pass; additionally, I have added several new tests (which pass): \\
\begin{tabularx}{\linewidth}{ |X|X| }
\hline
    \textbf{Test name} & \textbf{Test function} \\
\hhline{|=|=|}
    \texttt{by\_name\_not\_param.p} & Tests that using a function that takes a call by name parameter as a parameter generates an appropriate error. \\
\hline
    \texttt{rightarrow\_non\_int\_error.p} & Tests that using a non-integer call by name parameter leads to an appropriate error. \\
\hline
    \texttt{given\_named\_param\_test.p} & Contains the example given in the task description. This test also demonstrates that the compiler can optimise constant expressions passed by name. \\
\hline
    \texttt{lazy\_evaluate\_by\_name.p} & Tests that call by name parameters are not evaluated if they are not used. \\
\hline
    \texttt{reevaluate\_by\_name.p} & Tests that call by name parameters are re-evaluated each time they are used. \\
\hline
    \texttt{rightarrow\_same\_as\_var.p} & Tests that call by name parameter declarations are syntactically similar to call by reference parameter declarations (i.e. they can be followed by a list of parameters). \\
\hline
    \texttt{by\_name\_local.p} & Tests that a call by name parameter containing a local variable not in the scope of the called function works correctly. \\
\hline
    \texttt{by\_name\_nested\_function.p} & Tests that a call by name parameter containing implicit changes to state not in the scope of the called function works correctly. \\
\hline
    \texttt{by\_name\_to\_by\_name.p} & Tests that a call by name parameter can be passed as a call by name parameter to another function. \\
\hline
    \texttt{by\_reference\_to\_by\_name.p} & Tests that a call by reference parameter can be passed as a call by name parameter to another function. \\
\hline
    \texttt{by\_name\_not\_by\_ref.p} & Tests that a call by name parameter cannot be passed as a call by reference parameter to another function. \\
\hline
    \texttt{by\_name\_not\_assigned.p} & Tests that a call by reference parameter cannot be assigned to. \\
\hline
    \texttt{gps\_primes.p} & Tests an application of Knuth and Merner's general problem solver that calculates prime numbers. \\
\hline
    \texttt{jensen1.p} & Tests both a simple application of Jensen's device, and that local variables can be passed as call by name parameters. \\
\hline
    \texttt{jensen2.p} & Tests both a more complicated application of Jensen's device, and that global variables can be passed as call by name parameters. \\
\hline
    \texttt{jensen2d.p} & Tests using Jensen's device to calculate the sum of a matrix, and that locals can be passed by name. \\
\hline
    \texttt{jensen3.p} & Tests complicated application of Jensen's device, and that global variables can be passed as call by name parameters. \\
\hline
    \texttt{jensen\_function.p} & Calculates $1^4 + ... + 9^4$ using Jensen's device. \\
\hline
    \texttt{by\_name\_iterator.p} & Uses call by name parameters to implement an iterator-like construct \\
\hline
\end{tabularx}
\section{Appendix A}

\lstset{style=teststyle}
A full, automatically generated (with \texttt{hg diff -r initial\_revision\_number *.\{mll,mli,mly,ml\}}), description of the changes made to the compiler:
\lstinputlisting[language=diff]{diffset}
\section{Appendix B}

The full text of all tests, in alphabetical order, follows:
\lstset{style=pascal}

\begin{multicols}{2}

\subsection{\textbf{\texttt{bare\_continue.p}}}
\lstinputlisting[language=pascal,style=pascal]{lab4/test/bare_continue.p}

\subsection{\textbf{\texttt{by\_name\_iterator.p}}}
\lstinputlisting[language=pascal,style=pascal]{lab4/test/by_name_iterator.p}

\subsection{\textbf{\texttt{by\_name\_local.p}}}
\lstinputlisting[language=pascal,style=pascal]{lab4/test/by_name_local.p}

\subsection{\textbf{\texttt{by\_name\_nested\_function.p}}}
\lstinputlisting[language=pascal,style=pascal]{lab4/test/by_name_nested_function.p}

\subsection{\textbf{\texttt{by\_name\_not\_assigned.p}}}
\lstinputlisting[language=pascal,style=pascal]{lab4/test/by_name_not_assigned.p}

\subsection{\textbf{\texttt{by\_name\_not\_by\_ref.p}}}
\lstinputlisting[language=pascal,style=pascal]{lab4/test/by_name_not_by_ref.p}

\subsection{\textbf{\texttt{by\_name\_not\_param.p}}}
\lstinputlisting[language=pascal,style=pascal]{lab4/test/by_name_not_param.p}

\subsection{\textbf{\texttt{by\_name\_to\_by\_name.p}}}
\lstinputlisting[language=pascal,style=pascal]{lab4/test/by_name_to_by_name.p}

\subsection{\textbf{\texttt{by\_ref\_to\_by\_name.p}}}
\lstinputlisting[language=pascal,style=pascal]{lab4/test/by_ref_to_by_name.p}

\subsection{\textbf{\texttt{for\_continue.p}}}
\lstinputlisting[language=pascal,style=pascal]{lab4/test/for_continue.p}

\subsection{\textbf{\texttt{given\_named\_param\_test.p}}}
\lstinputlisting[language=pascal,style=pascal]{lab4/test/given_named_param_test.p}

\subsection{\textbf{\texttt{gps\_primes.p}}}
\lstinputlisting[language=pascal,style=pascal]{lab4/test/gps_primes.p}

\subsection{\textbf{\texttt{jensen1.p}}}
\lstinputlisting[language=pascal,style=pascal]{lab4/test/jensen1.p}

\subsection{\textbf{\texttt{jensen2.p}}}
\lstinputlisting[language=pascal,style=pascal]{lab4/test/jensen2.p}

\subsection{\textbf{\texttt{jensen2d.p}}}
\lstinputlisting[language=pascal,style=pascal]{lab4/test/jensen2d.p}

\subsection{\textbf{\texttt{jensen3.p}}}
\lstinputlisting[language=pascal,style=pascal]{lab4/test/jensen3.p}

\subsection{\textbf{\texttt{jensen\_function.p}}}
\lstinputlisting[language=pascal,style=pascal]{lab4/test/jensen_function.p}

\subsection{\textbf{\texttt{lazy\_evaluate\_by\_name.p}}}
\lstinputlisting[language=pascal,style=pascal]{lab4/test/lazy_evaluate_by_name.p}

\subsection{\textbf{\texttt{multiple\_continues.p}}}
\lstinputlisting[language=pascal,style=pascal]{lab4/test/multiple_continues.p}

\subsection{\textbf{\texttt{nested\_continue.p}}}
\lstinputlisting[language=pascal,style=pascal]{lab4/test/nested_continue.p}

\subsection{\textbf{\texttt{reevaluate\_by\_name.p}}}
\lstinputlisting[language=pascal,style=pascal]{lab4/test/reevaluate_by_name.p}

\subsection{\textbf{\texttt{repeat\_continue.p}}}
\lstinputlisting[language=pascal,style=pascal]{lab4/test/repeat_continue.p}

\subsection{\textbf{\texttt{rightarrow\_non\_int\_error.p}}}
\lstinputlisting[language=pascal,style=pascal]{lab4/test/rightarrow_non_int_error.p}

\subsection{\textbf{\texttt{rightarrow\_same\_as\_var.p}}}
\lstinputlisting[language=pascal,style=pascal]{lab4/test/rightarrow_same_as_var.p}

\subsection{\textbf{\texttt{while\_continue.p}}}
\lstinputlisting[language=pascal,style=pascal]{lab4/test/while_continue.p}

\end{multicols}

\newpage
\section{Sources}
Sources used:
\begin{itemize}
    \item The course book by M. Spivey
    \item The recommended book: Understanding and Writing Compilers by R. Bornat
    \item \url{https://en.wikipedia.org/wiki/Evaluation\_strategy} for general information about evaluation strategies.
    \item \url{https://en.wikipedia.org/wiki/Thunk} for information about thunks.
    \item \url{https://en.wikipedia.org/wiki/Jensen\%27s\_Device} for a description of Jensen's device, and for a description of Knuth and Merner's general problem solver.
    \item \url{https://cseweb.ucsd.edu/~goguen/courses/230w02/GPS.html} for a fuller description of Knuth and Merner's general problem solver.
    \item ALGOL 60 confidential, by D. Knuth and J. Merner, doi 10.1145/366573.366599
\end{itemize}

\tableofcontents

\end{document}
