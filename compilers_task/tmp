\subsection{\textbf{\texttt{lab4/test/bare\_continue.p}}}
\begin{lstlisting}[language=pascal]
(* A continue statement not inside a loop *)
begin
    continue;
end.

(*<<
"test/bare_continue.p", line 3: continue expression must be in a loop
>>*)
(*[[
]]*)
\end{lstlisting}
\subsection{\textbf{\texttt{lab4/test/by\_name\_local.p}}}
\begin{lstlisting}[language=pascal]
proc f(=> x : integer);
begin
    print_num(x);
    newline ();
    print_num(x);
    newline ()
end;
proc g(var x : integer) : integer;
begin
    x := x + 1;
    return x
end;

proc h();
    var x : integer;
begin
    x := 0;
    f(g(x) + 3)
end;
begin
    h()
end.

(*<<
4
5
>>*)
(*[[
@ picoPascal compiler output
	.include "fixup.s"
	.global pmain

@ proc f(=> x : integer);
	.text
_f:
	mov ip, sp
	stmfd sp!, {r0-r1}
	stmfd sp!, {r4-r10, fp, ip, lr}
	mov fp, sp
@     print_num(x);
	ldr r10, [fp, #44]
	ldr r0, [fp, #40]
	blx r0
	bl print_num
@     newline ();
	bl newline
@     print_num(x);
	ldr r10, [fp, #44]
	ldr r0, [fp, #40]
	blx r0
	bl print_num
@     newline ()
	bl newline
	ldmfd fp, {r4-r10, fp, sp, pc}
	.ltorg

@ proc g(var x : integer) : integer;
_g:
	mov ip, sp
	stmfd sp!, {r0-r1}
	stmfd sp!, {r4-r10, fp, ip, lr}
	mov fp, sp
@     x := x + 1;
	ldr r4, [fp, #40]
	ldr r0, [r4]
	add r0, r0, #1
	str r0, [r4]
@     return x
	ldr r0, [fp, #40]
	ldr r0, [r0]
	ldmfd fp, {r4-r10, fp, sp, pc}
	.ltorg

@ proc h();
__anonymous_1_689309695_917470854:
	mov ip, sp
	stmfd sp!, {r4-r10, fp, ip, lr}
	mov fp, sp
@ 
	ldr r0, [fp, #24]
	ldr r0, [r0, #24]
	add r0, r0, #-4
	bl _g
	add r0, r0, #3
	ldmfd fp, {r4-r10, fp, sp, pc}
	.ltorg

_h:
	mov ip, sp
	stmfd sp!, {r4-r10, fp, ip, lr}
	mov fp, sp
	sub sp, sp, #8
@     x := 0;
	mov r0, #0
	str r0, [fp, #-4]
@     f(g(x) + 3)
	mov r1, fp
	set r0, __anonymous_1_689309695_917470854
	bl _f
	ldmfd fp, {r4-r10, fp, sp, pc}
	.ltorg

pmain:
	mov ip, sp
	stmfd sp!, {r4-r10, fp, ip, lr}
	mov fp, sp
@     h()
	bl _h
	ldmfd fp, {r4-r10, fp, sp, pc}
	.ltorg

@ End
]]*)
\end{lstlisting}
\subsection{\textbf{\texttt{lab4/test/by\_name\_nested\_function.p}}}
\begin{lstlisting}[language=pascal]
proc f(=> x : integer);
begin
    print_num(x);
    newline ();
    print_num(x);
    newline ()
end;

proc h();
    var x : integer;
    proc g() : integer;
    begin
        x := x + 1;
        return x
    end;
begin
    x := 0;
    f(g() + 3)
end;
begin
    h()
end.

(*<<
4
5
>>*)
(*[[
@ picoPascal compiler output
	.include "fixup.s"
	.global pmain

@ proc f(=> x : integer);
	.text
_f:
	mov ip, sp
	stmfd sp!, {r0-r1}
	stmfd sp!, {r4-r10, fp, ip, lr}
	mov fp, sp
@     print_num(x);
	ldr r10, [fp, #44]
	ldr r0, [fp, #40]
	blx r0
	bl print_num
@     newline ();
	bl newline
@     print_num(x);
	ldr r10, [fp, #44]
	ldr r0, [fp, #40]
	blx r0
	bl print_num
@     newline ()
	bl newline
	ldmfd fp, {r4-r10, fp, sp, pc}
	.ltorg

@ proc h();
__anonymous_1_862948515_403086860:
	mov ip, sp
	stmfd sp!, {r4-r10, fp, ip, lr}
	mov fp, sp
@ 
	ldr r0, [fp, #24]
	ldr r10, [r0, #24]
	bl _g
	add r0, r0, #3
	ldmfd fp, {r4-r10, fp, sp, pc}
	.ltorg

_h:
	mov ip, sp
	stmfd sp!, {r4-r10, fp, ip, lr}
	mov fp, sp
	sub sp, sp, #8
@     x := 0;
	mov r0, #0
	str r0, [fp, #-4]
@     f(g() + 3)
	mov r1, fp
	set r0, __anonymous_1_862948515_403086860
	bl _f
	ldmfd fp, {r4-r10, fp, sp, pc}
	.ltorg

@     proc g() : integer;
_g:
	mov ip, sp
	stmfd sp!, {r4-r10, fp, ip, lr}
	mov fp, sp
@         x := x + 1;
	ldr r0, [fp, #24]
	add r4, r0, #-4
	ldr r0, [r4]
	add r0, r0, #1
	str r0, [r4]
@         return x
	ldr r0, [fp, #24]
	ldr r0, [r0, #-4]
	ldmfd fp, {r4-r10, fp, sp, pc}
	.ltorg

pmain:
	mov ip, sp
	stmfd sp!, {r4-r10, fp, ip, lr}
	mov fp, sp
@     h()
	bl _h
	ldmfd fp, {r4-r10, fp, sp, pc}
	.ltorg

@ End
]]*)
\end{lstlisting}
\subsection{\textbf{\texttt{lab4/test/by\_name\_not\_param.p}}}
\begin{lstlisting}[language=pascal]
(* a test to check if functions with call by name parameters used as parameters leads to errors *)

proc f(proc g(=> y:integer):integer):integer;
begin
    return 0;
end;
begin
    println("hello");
    newline()
end.

(*<<
"test/by_name_not_param.p", line 3: Functions that use call-by-name parameters cannot be parameters
>>*)
(*[[
]]*)
\end{lstlisting}
\subsection{\textbf{\texttt{lab4/test/by\_name\_to\_by\_name.p}}}
\begin{lstlisting}[language=pascal]
(* Tests that by-name parameters can be passed as by-name parameters *)

proc f(=> x : integer) : integer;
begin
    return x;
end;
proc g(=> x : integer) : integer;
begin
    return f(x);
end;
var x : integer;
begin
    x := 49;
    print_num(g(x));
    newline();
end.

(*<<
49
>>*)
(*[[
@ picoPascal compiler output
	.include "fixup.s"
	.global pmain

@ proc f(=> x : integer) : integer;
	.text
_f:
	mov ip, sp
	stmfd sp!, {r0-r1}
	stmfd sp!, {r4-r10, fp, ip, lr}
	mov fp, sp
@     return x;
	ldr r10, [fp, #44]
	ldr r0, [fp, #40]
	blx r0
	ldmfd fp, {r4-r10, fp, sp, pc}
	.ltorg

@ proc g(=> x : integer) : integer;
_g:
	mov ip, sp
	stmfd sp!, {r0-r1}
	stmfd sp!, {r4-r10, fp, ip, lr}
	mov fp, sp
@     return f(x);
	mov r1, fp
	set r0, __anonymous_1_64094289_270919846
	bl _f
	ldmfd fp, {r4-r10, fp, sp, pc}
	.ltorg

pmain:
	mov ip, sp
	stmfd sp!, {r4-r10, fp, ip, lr}
	mov fp, sp
@     x := 49;
	mov r0, #49
	set r1, _x
	str r0, [r1]
@     print_num(g(x));
	mov r1, fp
	set r0, __anonymous_2_872736059_941440214
	bl _g
	bl print_num
@     newline();
	bl newline
	ldmfd fp, {r4-r10, fp, sp, pc}
	.ltorg

__anonymous_1_64094289_270919846:
	mov ip, sp
	stmfd sp!, {r4-r10, fp, ip, lr}
	mov fp, sp
@ 
	ldr r4, [fp, #24]
	ldr r10, [r4, #44]
	ldr r0, [r4, #40]
	blx r0
	ldmfd fp, {r4-r10, fp, sp, pc}
	.ltorg

__anonymous_2_872736059_941440214:
	mov ip, sp
	stmfd sp!, {r4-r10, fp, ip, lr}
	mov fp, sp
	set r0, _x
	ldr r0, [r0]
	ldmfd fp, {r4-r10, fp, sp, pc}
	.ltorg

	.comm _x, 4, 4
@ End
]]*)
\end{lstlisting}
\subsection{\textbf{\texttt{lab4/test/by\_ref\_to\_by\_name.p}}}
\begin{lstlisting}[language=pascal]
(* Tests that by-reference parameters can be passed as by-name parameters *)

proc f(=> x : integer) : integer;
begin
    return x;
end;
proc g(var x : integer) : integer;
begin
    return f(x);
end;
var x : integer;
begin
    x := 23;
    print_num(g(x));
    newline();
end.

(*<<
23
>>*)
(*[[
@ picoPascal compiler output
	.include "fixup.s"
	.global pmain

@ proc f(=> x : integer) : integer;
	.text
_f:
	mov ip, sp
	stmfd sp!, {r0-r1}
	stmfd sp!, {r4-r10, fp, ip, lr}
	mov fp, sp
@     return x;
	ldr r10, [fp, #44]
	ldr r0, [fp, #40]
	blx r0
	ldmfd fp, {r4-r10, fp, sp, pc}
	.ltorg

@ proc g(var x : integer) : integer;
_g:
	mov ip, sp
	stmfd sp!, {r0-r1}
	stmfd sp!, {r4-r10, fp, ip, lr}
	mov fp, sp
@     return f(x);
	mov r1, fp
	set r0, __anonymous_1_324510095_333899986
	bl _f
	ldmfd fp, {r4-r10, fp, sp, pc}
	.ltorg

pmain:
	mov ip, sp
	stmfd sp!, {r4-r10, fp, ip, lr}
	mov fp, sp
@     x := 23;
	set r4, _x
	mov r0, #23
	str r0, [r4]
@     print_num(g(x));
	mov r0, r4
	bl _g
	bl print_num
@     newline();
	bl newline
	ldmfd fp, {r4-r10, fp, sp, pc}
	.ltorg

__anonymous_1_324510095_333899986:
	mov ip, sp
	stmfd sp!, {r4-r10, fp, ip, lr}
	mov fp, sp
@ 
	ldr r0, [fp, #24]
	ldr r0, [r0, #40]
	ldr r0, [r0]
	ldmfd fp, {r4-r10, fp, sp, pc}
	.ltorg

	.comm _x, 4, 4
@ End
]]*)
\end{lstlisting}
\subsection{\textbf{\texttt{lab4/test/for\_continue.p}}}
\begin{lstlisting}[language=pascal]
(* A continue statement inside a for loop *)

var i : integer;
begin
    for i := 0 to 100 do
        if i mod 2 = 0 then continue end;
        print_num(i);
        print_char(' ')
    end;
    newline()
end.

(*<<
1 3 5 7 9 11 13 15 17 19 21 23 25 27 29 31 33 35 37 39 41 43 45 47 49 51 53 55 57 59 61 63 65 67 69 71 73 75 77 79 81 83 85 87 89 91 93 95 97 99 
>>*)
(*[[
@ picoPascal compiler output
	.include "fixup.s"
	.global pmain

	.text
pmain:
	mov ip, sp
	stmfd sp!, {r4-r10, fp, ip, lr}
	mov fp, sp
@     for i := 0 to 100 do
	mov r0, #0
	set r1, _i
	str r0, [r1]
	mov r4, #100
.L3:
	set r5, _i
	ldr r6, [r5]
	cmp r6, r4
	bgt .L4
@         if i mod 2 = 0 then continue end;
	mov r1, #2
	mov r0, r6
	bl int_mod
	cmp r0, #0
	beq .L5
@         print_num(i);
	ldr r0, [r5]
	bl print_num
@         print_char(' ')
	mov r0, #32
	bl print_char
.L5:
	set r5, _i
	ldr r0, [r5]
	add r0, r0, #1
	str r0, [r5]
	b .L3
.L4:
@     newline()
	bl newline
	ldmfd fp, {r4-r10, fp, sp, pc}
	.ltorg

	.comm _i, 4, 4
@ End
]]*)
\end{lstlisting}
\subsection{\textbf{\texttt{lab4/test/given\_named\_param\_test.p}}}
\begin{lstlisting}[language=pascal]
(* The test given in the task description for named parameters *)
var g: integer;
proc println (x:integer);
begin
    print_num(x);
    newline()
end;
proc p (=> x:integer): integer;
begin
    g := g+1;
    return x+x
end;
begin
    g := 0;
    (* evaluates 2+3 twice and prints out 10 *)
    println(p(2+3));
    (* g=1 at this point *)
    (* when p needs the value of g, it will be equal to 2, so p will return 4 *)
    println(p(g));
    (* g=2 at this point *)
    (* 28 will be printed out *)
    println(p(p(7)));
    (* g=5 at this point *)
    println(g)
end.

(*<<
10
4
28
5
>>*)
(*[[
@ picoPascal compiler output
	.include "fixup.s"
	.global pmain

@ proc println (x:integer);
	.text
_println:
	mov ip, sp
	stmfd sp!, {r0-r1}
	stmfd sp!, {r4-r10, fp, ip, lr}
	mov fp, sp
@     print_num(x);
	ldr r0, [fp, #40]
	bl print_num
@     newline()
	bl newline
	ldmfd fp, {r4-r10, fp, sp, pc}
	.ltorg

@ proc p (=> x:integer): integer;
_p:
	mov ip, sp
	stmfd sp!, {r0-r1}
	stmfd sp!, {r4-r10, fp, ip, lr}
	mov fp, sp
@     g := g+1;
	set r4, _g
	ldr r0, [r4]
	add r0, r0, #1
	str r0, [r4]
@     return x+x
	ldr r10, [fp, #44]
	ldr r0, [fp, #40]
	blx r0
	ldr r10, [fp, #44]
	mov r4, r0
	ldr r0, [fp, #40]
	blx r0
	add r0, r4, r0
	ldmfd fp, {r4-r10, fp, sp, pc}
	.ltorg

__anonymous_1_845510314_1006865108:
	mov ip, sp
	stmfd sp!, {r4-r10, fp, ip, lr}
	mov fp, sp
@ 
	mov r0, #5
	ldmfd fp, {r4-r10, fp, sp, pc}
	.ltorg

__anonymous_2_28353362_432984356:
	mov ip, sp
	stmfd sp!, {r4-r10, fp, ip, lr}
	mov fp, sp
	set r0, _g
	ldr r0, [r0]
	ldmfd fp, {r4-r10, fp, sp, pc}
	.ltorg

__anonymous_4_1037806458_215612081:
	mov ip, sp
	stmfd sp!, {r4-r10, fp, ip, lr}
	mov fp, sp
	mov r0, #7
	ldmfd fp, {r4-r10, fp, sp, pc}
	.ltorg

__anonymous_3_895163257_356191526:
	mov ip, sp
	stmfd sp!, {r4-r10, fp, ip, lr}
	mov fp, sp
	mov r1, fp
	set r0, __anonymous_4_1037806458_215612081
	bl _p
	ldmfd fp, {r4-r10, fp, sp, pc}
	.ltorg

pmain:
	mov ip, sp
	stmfd sp!, {r4-r10, fp, ip, lr}
	mov fp, sp
@     g := 0;
	set r4, _g
	mov r0, #0
	str r0, [r4]
@     println(p(2+3));
	mov r1, fp
	set r0, __anonymous_1_845510314_1006865108
	bl _p
	bl _println
@     println(p(g));
	mov r1, fp
	set r0, __anonymous_2_28353362_432984356
	bl _p
	bl _println
@     println(p(p(7)));
	mov r1, fp
	set r0, __anonymous_3_895163257_356191526
	bl _p
	bl _println
@     println(g)
	ldr r0, [r4]
	bl _println
	ldmfd fp, {r4-r10, fp, sp, pc}
	.ltorg

	.comm _g, 4, 4
@ End
]]*)
\end{lstlisting}
\subsection{\textbf{\texttt{lab4/test/gps\_primes.p}}}
\begin{lstlisting}[language=pascal]
(* Knuth and Merner general problem solver, from ALGOL 60 confidential; original text:
real procedure GPS(I, N, Z, V); real I, N, Z, V;
   begin for I := 1 step 1 until N do Z := V; GPS := 1 end;

Method for finding primes with the gps:
I := GPS(I, if I=0 then -1.0 else I, P, if I=1 then 1.0 else
   if GPS(A, I, Z, if A=1 then 1.0 else
      if entier(A)×(entier(I)÷entier(A))=entier(I) ∧ A<I
      then 0.0 else Z) = Z then
      (if P<m then P+1 else I×GPS(A, 1.0, I, -1.0)) else P)
      *)
 
proc gps(var i : integer; => n : integer; var z : integer; => v : integer) : integer;
    var limit : integer;
begin
    i := 1;
    while i <= n do
        z := v;
        i := i+1;
    end;
    return 1;
end;

proc f1(var i : integer) : integer;
begin
    if i = 0 then
        return -1;
    else
        return i;
    end;
end;

proc f2(var a, i : integer; var z: integer) : integer;
begin
    if a = 1 then
        return 1;
    else
        if ((a * (i div a) = i) and (a < i)) then
            return 0;
        else
            return z;
        end;
    end;
end;

proc f3(=> p : integer; var a : integer; => m : integer; var i : integer; var z : integer) : integer;
    var tmp_i: integer;
begin
    if i = 1 then
        return 1
    else
        if gps(a, i, z, f2(a, i, z)) = z then
            if p < m then
                return p + 1;
            else 
                (* This temporary is necessary since I can't force the lhs to be evaluated before the rhs *)
                tmp_i := i;
                return tmp_i * gps(a, 1, i, -1)
            end;
        else
            return p;
        end;
    end;
end;

proc find_prime(m : integer) : integer;
    var i, z, p, a : integer;
begin
    i := gps(i, f1(i), p, f3(p, a, m, i, z));
    return p;
end;

var i : integer;
begin
    i := 1;
    while i < 20 do
        print_num(find_prime(i)); newline();
        i := i+1;
    end;
    print_num(find_prime(100)); newline();
end.

(*<<
2
3
5
7
11
13
17
19
23
29
31
37
41
43
47
53
59
61
67
541
>>*)
(*[[
@ picoPascal compiler output
	.include "fixup.s"
	.global pmain

@ proc gps(var i : integer; => n : integer; var z : integer; => v : integer) : integer;
	.text
_gps:
	mov ip, sp
	stmfd sp!, {r0-r3}
	stmfd sp!, {r4-r10, fp, ip, lr}
	mov fp, sp
@     i := 1;
	mov r0, #1
	ldr r1, [fp, #40]
	str r0, [r1]
.L3:
@     while i <= n do
	ldr r10, [fp, #48]
	ldr r0, [fp, #44]
	blx r0
	ldr r1, [fp, #40]
	ldr r1, [r1]
	cmp r1, r0
	bgt .L5
@         z := v;
	ldr r10, [fp, #60]
	ldr r0, [fp, #56]
	blx r0
	ldr r1, [fp, #52]
	str r0, [r1]
@         i := i+1;
	ldr r5, [fp, #40]
	ldr r0, [r5]
	add r0, r0, #1
	str r0, [r5]
	b .L3
.L5:
@     return 1;
	mov r0, #1
	ldmfd fp, {r4-r10, fp, sp, pc}
	.ltorg

@ proc f1(var i : integer) : integer;
_f1:
	mov ip, sp
	stmfd sp!, {r0-r1}
	stmfd sp!, {r4-r10, fp, ip, lr}
	mov fp, sp
@     if i = 0 then
	ldr r0, [fp, #40]
	ldr r0, [r0]
	cmp r0, #0
	bne .L8
@         return -1;
	mov r0, #-1
	b .L6
.L8:
@         return i;
	ldr r0, [fp, #40]
	ldr r0, [r0]
.L6:
	ldmfd fp, {r4-r10, fp, sp, pc}
	.ltorg

@ proc f2(var a, i : integer; var z: integer) : integer;
_f2:
	mov ip, sp
	stmfd sp!, {r0-r3}
	stmfd sp!, {r4-r10, fp, ip, lr}
	mov fp, sp
@     if a = 1 then
	ldr r0, [fp, #40]
	ldr r0, [r0]
	cmp r0, #1
	bne .L12
@         return 1;
	mov r0, #1
	b .L10
.L12:
@         if ((a * (i div a) = i) and (a < i)) then
	ldr r0, [fp, #40]
	ldr r4, [r0]
	mov r1, r4
	ldr r0, [fp, #44]
	ldr r0, [r0]
	bl int_div
	ldr r1, [fp, #44]
	ldr r5, [r1]
	mul r0, r4, r0
	cmp r0, r5
	bne .L15
	ldr r0, [fp, #40]
	ldr r0, [r0]
	cmp r0, r5
	bge .L15
@             return 0;
	mov r0, #0
	b .L10
.L15:
@             return z;
	ldr r0, [fp, #48]
	ldr r0, [r0]
.L10:
	ldmfd fp, {r4-r10, fp, sp, pc}
	.ltorg

@ proc f3(=> p : integer; var a : integer; => m : integer; var i : integer; var z : integer) : integer;
_f3:
	mov ip, sp
	stmfd sp!, {r0-r3}
	stmfd sp!, {r4-r10, fp, ip, lr}
	mov fp, sp
	sub sp, sp, #8
@     if i = 1 then
	ldr r0, [fp, #60]
	ldr r0, [r0]
	cmp r0, #1
	bne .L20
@         return 1
	mov r0, #1
	b .L18
.L20:
@         if gps(a, i, z, f2(a, i, z)) = z then
	str fp, [sp, #4]
	set r0, __anonymous_4_166888106_586343709
	str r0, [sp]
	ldr r3, [fp, #64]
	mov r2, fp
	set r1, __anonymous_3_668090159_527260969
	ldr r0, [fp, #48]
	bl _gps
	ldr r1, [fp, #64]
	ldr r1, [r1]
	cmp r0, r1
	bne .L23
@             if p < m then
	ldr r10, [fp, #44]
	ldr r0, [fp, #40]
	blx r0
	ldr r10, [fp, #56]
	mov r5, r0
	ldr r0, [fp, #52]
	blx r0
	cmp r5, r0
	bge .L26
@                 return p + 1;
	ldr r10, [fp, #44]
	ldr r0, [fp, #40]
	blx r0
	add r0, r0, #1
	b .L18
.L26:
@                 tmp_i := i;
	ldr r5, [fp, #60]
	ldr r4, [r5]
@                 return tmp_i * gps(a, 1, i, -1)
	str fp, [sp, #4]
	set r0, __anonymous_2_72698089_457399802
	str r0, [sp]
	mov r3, r5
	mov r2, fp
	set r1, __anonymous_1_653882326_622386379
	ldr r0, [fp, #48]
	bl _gps
	mul r0, r4, r0
	b .L18
.L23:
@             return p;
	ldr r10, [fp, #44]
	ldr r0, [fp, #40]
	blx r0
.L18:
	ldmfd fp, {r4-r10, fp, sp, pc}
	.ltorg

@ proc find_prime(m : integer) : integer;
_find_prime:
	mov ip, sp
	stmfd sp!, {r0-r1}
	stmfd sp!, {r4-r10, fp, ip, lr}
	mov fp, sp
	sub sp, sp, #24
@     i := gps(i, f1(i), p, f3(p, a, m, i, z));
	str fp, [sp, #4]
	set r0, __anonymous_6_126566748_758242834
	str r0, [sp]
	add r3, fp, #-12
	mov r2, fp
	set r1, __anonymous_5_9176859_622467405
	add r0, fp, #-4
	bl _gps
	str r0, [fp, #-4]
@     return p;
	ldr r0, [fp, #-12]
	ldmfd fp, {r4-r10, fp, sp, pc}
	.ltorg

pmain:
	mov ip, sp
	stmfd sp!, {r4-r10, fp, ip, lr}
	mov fp, sp
@     i := 1;
	mov r0, #1
	set r1, _i
	str r0, [r1]
.L30:
@     while i < 20 do
	set r4, _i
	ldr r5, [r4]
	cmp r5, #20
	bge .L32
@         print_num(find_prime(i)); newline();
	mov r0, r5
	bl _find_prime
	bl print_num
	bl newline
@         i := i+1;
	ldr r0, [r4]
	add r0, r0, #1
	str r0, [r4]
	b .L30
.L32:
@     print_num(find_prime(100)); newline();
	mov r0, #100
	bl _find_prime
	bl print_num
	bl newline
	ldmfd fp, {r4-r10, fp, sp, pc}
	.ltorg

__anonymous_1_653882326_622386379:
	mov ip, sp
	stmfd sp!, {r4-r10, fp, ip, lr}
	mov fp, sp
@ 
	mov r0, #1
	ldmfd fp, {r4-r10, fp, sp, pc}
	.ltorg

__anonymous_2_72698089_457399802:
	mov ip, sp
	stmfd sp!, {r4-r10, fp, ip, lr}
	mov fp, sp
	mov r0, #-1
	ldmfd fp, {r4-r10, fp, sp, pc}
	.ltorg

__anonymous_3_668090159_527260969:
	mov ip, sp
	stmfd sp!, {r4-r10, fp, ip, lr}
	mov fp, sp
	ldr r0, [fp, #24]
	ldr r0, [r0, #60]
	ldr r0, [r0]
	ldmfd fp, {r4-r10, fp, sp, pc}
	.ltorg

__anonymous_4_166888106_586343709:
	mov ip, sp
	stmfd sp!, {r4-r10, fp, ip, lr}
	mov fp, sp
	ldr r4, [fp, #24]
	ldr r2, [r4, #64]
	ldr r1, [r4, #60]
	ldr r0, [r4, #48]
	bl _f2
	ldmfd fp, {r4-r10, fp, sp, pc}
	.ltorg

__anonymous_5_9176859_622467405:
	mov ip, sp
	stmfd sp!, {r4-r10, fp, ip, lr}
	mov fp, sp
	ldr r0, [fp, #24]
	add r0, r0, #-4
	bl _f1
	ldmfd fp, {r4-r10, fp, sp, pc}
	.ltorg

__anonymous_6_126566748_758242834:
	mov ip, sp
	stmfd sp!, {r4-r10, fp, ip, lr}
	mov fp, sp
	sub sp, sp, #16
	ldr r4, [fp, #24]
	add r0, r4, #-8
	str r0, [sp, #8]
	add r0, r4, #-4
	str r0, [sp, #4]
	str fp, [sp]
	set r3, __anonymous_8_774902323_49565957
	add r2, r4, #-16
	mov r1, fp
	set r0, __anonymous_7_1070535197_277242887
	bl _f3
	ldmfd fp, {r4-r10, fp, sp, pc}
	.ltorg

__anonymous_7_1070535197_277242887:
	mov ip, sp
	stmfd sp!, {r4-r10, fp, ip, lr}
	mov fp, sp
	ldr r0, [fp, #24]
	ldr r0, [r0, #24]
	ldr r0, [r0, #-12]
	ldmfd fp, {r4-r10, fp, sp, pc}
	.ltorg

__anonymous_8_774902323_49565957:
	mov ip, sp
	stmfd sp!, {r4-r10, fp, ip, lr}
	mov fp, sp
	ldr r0, [fp, #24]
	ldr r0, [r0, #24]
	ldr r0, [r0, #40]
	ldmfd fp, {r4-r10, fp, sp, pc}
	.ltorg

	.comm _i, 4, 4
@ End
]]*)
\end{lstlisting}
\subsection{\textbf{\texttt{lab4/test/jensen1.p}}}
\begin{lstlisting}[language=pascal]
(* Jensen's device, simple application, using local variables*)

proc test();
    var i : integer;
    var a: array 10 of integer;

    proc sum(var i: integer; left, right: integer; => v: integer): integer;
        var retval: integer;
    begin
        retval := 0;
        i := left;
        while i <= right do
            retval := retval + v;
            i := i+1;
        end;
        return retval;
    end;

begin
    a[0] := 0;
    a[1] := 1;
    a[2] := 2;
    a[3] := 3;
    a[4] := 4;
    a[5] := 5;
    a[6] := 6;
    a[7] := 7;
    a[8] := 8;
    a[9] := 9;
    print_num(sum(i, 0, 9, a[i])); newline();
end;
begin
    test();
end.

(*<<
45
>>*)
(*[[
@ picoPascal compiler output
	.include "fixup.s"
	.global pmain

@ proc test();
	.text
_test:
	mov ip, sp
	stmfd sp!, {r4-r10, fp, ip, lr}
	mov fp, sp
	sub sp, sp, #48
@     a[0] := 0;
	mov r0, #0
	str r0, [fp, #-44]
@     a[1] := 1;
	mov r0, #1
	str r0, [fp, #-40]
@     a[2] := 2;
	mov r0, #2
	str r0, [fp, #-36]
@     a[3] := 3;
	mov r0, #3
	str r0, [fp, #-32]
@     a[4] := 4;
	mov r0, #4
	str r0, [fp, #-28]
@     a[5] := 5;
	mov r0, #5
	str r0, [fp, #-24]
@     a[6] := 6;
	mov r0, #6
	str r0, [fp, #-20]
@     a[7] := 7;
	mov r0, #7
	str r0, [fp, #-16]
@     a[8] := 8;
	mov r0, #8
	str r0, [fp, #-12]
@     a[9] := 9;
	mov r0, #9
	str r0, [fp, #-8]
@     print_num(sum(i, 0, 9, a[i])); newline();
	str fp, [sp]
	set r3, __anonymous_1_34343979_142517942
	mov r2, #9
	mov r1, #0
	add r0, fp, #-4
	mov r10, fp
	bl _sum
	bl print_num
	bl newline
	ldmfd fp, {r4-r10, fp, sp, pc}
	.ltorg

@     proc sum(var i: integer; left, right: integer; => v: integer): integer;
_sum:
	mov ip, sp
	stmfd sp!, {r0-r3}
	stmfd sp!, {r4-r10, fp, ip, lr}
	mov fp, sp
@         retval := 0;
	mov r4, #0
@         i := left;
	ldr r0, [fp, #44]
	ldr r1, [fp, #40]
	str r0, [r1]
.L4:
@         while i <= right do
	ldr r0, [fp, #40]
	ldr r0, [r0]
	ldr r1, [fp, #48]
	cmp r0, r1
	bgt .L6
@             retval := retval + v;
	ldr r10, [fp, #56]
	ldr r0, [fp, #52]
	blx r0
	add r4, r4, r0
@             i := i+1;
	ldr r5, [fp, #40]
	ldr r0, [r5]
	add r0, r0, #1
	str r0, [r5]
	b .L4
.L6:
@         return retval;
	mov r0, r4
	ldmfd fp, {r4-r10, fp, sp, pc}
	.ltorg

pmain:
	mov ip, sp
	stmfd sp!, {r4-r10, fp, ip, lr}
	mov fp, sp
@     test();
	bl _test
	ldmfd fp, {r4-r10, fp, sp, pc}
	.ltorg

__anonymous_1_34343979_142517942:
	mov ip, sp
	stmfd sp!, {r4-r10, fp, ip, lr}
	mov fp, sp
@ 
	ldr r4, [fp, #24]
	add r0, r4, #-44
	ldr r1, [r4, #-4]
	lsl r1, r1, #2
	add r0, r0, r1
	ldr r0, [r0]
	ldmfd fp, {r4-r10, fp, sp, pc}
	.ltorg

@ End
]]*)
\end{lstlisting}
\subsection{\textbf{\texttt{lab4/test/jensen2.p}}}
\begin{lstlisting}[language=pascal]
(* Jensen's device, more involved application, using global variables*)

var i : integer;

var a: array 10 of integer;

proc sum(var i: integer; left, right:integer; => v: integer): integer;
    var retval: integer;
begin
    retval := 0;
    i := left;
    while i <= right do
        retval := retval + v;
        i := i+1;
    end;
    return retval;
end;

proc print_and_ret(x : integer): integer;
begin
    print_num(x);
    newline();
    return x;
end;

begin
    a[0] := 0;
    a[1] := 1;
    a[2] := 2;
    a[3] := 3;
    a[4] := 4;
    a[5] := 5;
    a[6] := 6;
    a[7] := 7;
    a[8] := 8;
    a[9] := 9;
    print_num(sum(i, 0, 9, print_and_ret(a[i] * a[i]))); newline();
end.

(*<<
0
1
4
9
16
25
36
49
64
81
285
>>*)
(*[[
@ picoPascal compiler output
	.include "fixup.s"
	.global pmain

@ proc sum(var i: integer; left, right:integer; => v: integer): integer;
	.text
_sum:
	mov ip, sp
	stmfd sp!, {r0-r3}
	stmfd sp!, {r4-r10, fp, ip, lr}
	mov fp, sp
@     retval := 0;
	mov r4, #0
@     i := left;
	ldr r0, [fp, #44]
	ldr r1, [fp, #40]
	str r0, [r1]
.L3:
@     while i <= right do
	ldr r0, [fp, #40]
	ldr r0, [r0]
	ldr r1, [fp, #48]
	cmp r0, r1
	bgt .L5
@         retval := retval + v;
	ldr r10, [fp, #56]
	ldr r0, [fp, #52]
	blx r0
	add r4, r4, r0
@         i := i+1;
	ldr r5, [fp, #40]
	ldr r0, [r5]
	add r0, r0, #1
	str r0, [r5]
	b .L3
.L5:
@     return retval;
	mov r0, r4
	ldmfd fp, {r4-r10, fp, sp, pc}
	.ltorg

@ proc print_and_ret(x : integer): integer;
_print_and_ret:
	mov ip, sp
	stmfd sp!, {r0-r1}
	stmfd sp!, {r4-r10, fp, ip, lr}
	mov fp, sp
@     print_num(x);
	ldr r0, [fp, #40]
	bl print_num
@     newline();
	bl newline
@     return x;
	ldr r0, [fp, #40]
	ldmfd fp, {r4-r10, fp, sp, pc}
	.ltorg

pmain:
	mov ip, sp
	stmfd sp!, {r4-r10, fp, ip, lr}
	mov fp, sp
	sub sp, sp, #8
@     a[0] := 0;
	set r4, _a
	mov r0, #0
	str r0, [r4]
@     a[1] := 1;
	mov r0, #1
	str r0, [r4, #4]
@     a[2] := 2;
	mov r0, #2
	str r0, [r4, #8]
@     a[3] := 3;
	mov r0, #3
	str r0, [r4, #12]
@     a[4] := 4;
	mov r0, #4
	str r0, [r4, #16]
@     a[5] := 5;
	mov r0, #5
	str r0, [r4, #20]
@     a[6] := 6;
	mov r0, #6
	str r0, [r4, #24]
@     a[7] := 7;
	mov r0, #7
	str r0, [r4, #28]
@     a[8] := 8;
	mov r0, #8
	str r0, [r4, #32]
@     a[9] := 9;
	mov r0, #9
	str r0, [r4, #36]
@     print_num(sum(i, 0, 9, print_and_ret(a[i] * a[i]))); newline();
	str fp, [sp]
	set r3, __anonymous_1_185975715_552376020
	mov r2, #9
	mov r1, #0
	set r0, _i
	bl _sum
	bl print_num
	bl newline
	ldmfd fp, {r4-r10, fp, sp, pc}
	.ltorg

__anonymous_1_185975715_552376020:
	mov ip, sp
	stmfd sp!, {r4-r10, fp, ip, lr}
	mov fp, sp
@ 
	set r0, _a
	set r1, _i
	ldr r1, [r1]
	lsl r1, r1, #2
	add r0, r0, r1
	ldr r4, [r0]
	mul r0, r4, r4
	bl _print_and_ret
	ldmfd fp, {r4-r10, fp, sp, pc}
	.ltorg

	.comm _i, 4, 4
	.comm _a, 40, 4
@ End
]]*)
\end{lstlisting}
\subsection{\textbf{\texttt{lab4/test/jensen2d.p}}}
\begin{lstlisting}[language=pascal]
(* Jensen's device, 2d application, using local variables*)

proc test();
    var i, j: integer;

    var a: array 10 of array 10 of integer;

    proc sum(var i: integer; left, right: integer; => v: integer): integer;
        var retval: integer;
    begin
        retval := 0;
        i := left;
        while i <= right do
            retval := retval + v;
            i := i+1;
        end;
        return retval;
    end;
begin
    i := 0;
    while i < 10 do
        j := 0;
        while j < 10 do
            a[i][j] := i * j;
            j := j + 1;
        end;
        i := i+1;
    end;

    print_num(sum(i, 0, 9, sum(j, 0, 9, a[i][j]))); newline();
end;
begin
    test();
end.

(*<<
2025
>>*)
(*[[
@ picoPascal compiler output
	.include "fixup.s"
	.global pmain

@ proc test();
	.text
_test:
	mov ip, sp
	stmfd sp!, {r4-r10, fp, ip, lr}
	mov fp, sp
	sub sp, sp, #416
@     i := 0;
	mov r0, #0
	str r0, [fp, #-4]
.L3:
@     while i < 10 do
	ldr r0, [fp, #-4]
	cmp r0, #10
	bge .L5
@         j := 0;
	mov r0, #0
	str r0, [fp, #-8]
.L6:
@         while j < 10 do
	ldr r4, [fp, #-8]
	cmp r4, #10
	bge .L8
@             a[i][j] := i * j;
	ldr r5, [fp, #-4]
	mul r0, r5, r4
	add r1, fp, #-408
	mov r2, #40
	mul r2, r5, r2
	add r1, r1, r2
	lsl r2, r4, #2
	add r1, r1, r2
	str r0, [r1]
@             j := j + 1;
	ldr r0, [fp, #-8]
	add r0, r0, #1
	str r0, [fp, #-8]
	b .L6
.L8:
@         i := i+1;
	ldr r0, [fp, #-4]
	add r0, r0, #1
	str r0, [fp, #-4]
	b .L3
.L5:
@     print_num(sum(i, 0, 9, sum(j, 0, 9, a[i][j]))); newline();
	str fp, [sp]
	set r3, __anonymous_1_83722889_557874811
	mov r2, #9
	mov r1, #0
	add r0, fp, #-4
	mov r10, fp
	bl _sum
	bl print_num
	bl newline
	ldmfd fp, {r4-r10, fp, sp, pc}
	.ltorg

@     proc sum(var i: integer; left, right: integer; => v: integer): integer;
_sum:
	mov ip, sp
	stmfd sp!, {r0-r3}
	stmfd sp!, {r4-r10, fp, ip, lr}
	mov fp, sp
@         retval := 0;
	mov r4, #0
@         i := left;
	ldr r0, [fp, #44]
	ldr r1, [fp, #40]
	str r0, [r1]
.L10:
@         while i <= right do
	ldr r0, [fp, #40]
	ldr r0, [r0]
	ldr r1, [fp, #48]
	cmp r0, r1
	bgt .L12
@             retval := retval + v;
	ldr r10, [fp, #56]
	ldr r0, [fp, #52]
	blx r0
	add r4, r4, r0
@             i := i+1;
	ldr r5, [fp, #40]
	ldr r0, [r5]
	add r0, r0, #1
	str r0, [r5]
	b .L10
.L12:
@         return retval;
	mov r0, r4
	ldmfd fp, {r4-r10, fp, sp, pc}
	.ltorg

pmain:
	mov ip, sp
	stmfd sp!, {r4-r10, fp, ip, lr}
	mov fp, sp
@     test();
	bl _test
	ldmfd fp, {r4-r10, fp, sp, pc}
	.ltorg

__anonymous_1_83722889_557874811:
	mov ip, sp
	stmfd sp!, {r4-r10, fp, ip, lr}
	mov fp, sp
	sub sp, sp, #8
@ 
	ldr r4, [fp, #24]
	str fp, [sp]
	set r3, __anonymous_2_140095478_37789682
	mov r2, #9
	mov r1, #0
	add r0, r4, #-8
	mov r10, r4
	bl _sum
	ldmfd fp, {r4-r10, fp, sp, pc}
	.ltorg

__anonymous_2_140095478_37789682:
	mov ip, sp
	stmfd sp!, {r4-r10, fp, ip, lr}
	mov fp, sp
	ldr r0, [fp, #24]
	ldr r4, [r0, #24]
	add r0, r4, #-408
	ldr r1, [r4, #-4]
	mov r2, #40
	mul r1, r1, r2
	add r0, r0, r1
	ldr r1, [r4, #-8]
	lsl r1, r1, #2
	add r0, r0, r1
	ldr r0, [r0]
	ldmfd fp, {r4-r10, fp, sp, pc}
	.ltorg

@ End
]]*)
\end{lstlisting}
\subsection{\textbf{\texttt{lab4/test/jensen3.p}}}
\begin{lstlisting}[language=pascal]
(* Jensen's device, complicated application, with global variables*)

var i : integer;

var a : array 10 of integer;

proc sum(var i: integer; left, right:integer; => v: integer): integer;
    var retval: integer;
begin
    retval := 0;
    i := left;
    while i <= right do
        retval := retval + v;
        i := i+1;
    end;
    return retval;
end;

proc return_a_i_and_increment_i(): integer;
    var retval: integer;
begin
    retval := a[i];
    i := i+1;
    return retval;
end;


begin
    a[0] := 0;
    a[1] := 1;
    a[2] := 2;
    a[3] := 3;
    a[4] := 4;
    a[5] := 5;
    a[6] := 6;
    a[7] := 7;
    a[8] := 8;
    a[9] := 9;
    print_num(sum(i, 0, 9, return_a_i_and_increment_i())); newline();
end.

(*<<
20
>>*)
(*[[
@ picoPascal compiler output
	.include "fixup.s"
	.global pmain

@ proc sum(var i: integer; left, right:integer; => v: integer): integer;
	.text
_sum:
	mov ip, sp
	stmfd sp!, {r0-r3}
	stmfd sp!, {r4-r10, fp, ip, lr}
	mov fp, sp
@     retval := 0;
	mov r4, #0
@     i := left;
	ldr r0, [fp, #44]
	ldr r1, [fp, #40]
	str r0, [r1]
.L3:
@     while i <= right do
	ldr r0, [fp, #40]
	ldr r0, [r0]
	ldr r1, [fp, #48]
	cmp r0, r1
	bgt .L5
@         retval := retval + v;
	ldr r10, [fp, #56]
	ldr r0, [fp, #52]
	blx r0
	add r4, r4, r0
@         i := i+1;
	ldr r5, [fp, #40]
	ldr r0, [r5]
	add r0, r0, #1
	str r0, [r5]
	b .L3
.L5:
@     return retval;
	mov r0, r4
	ldmfd fp, {r4-r10, fp, sp, pc}
	.ltorg

@ proc return_a_i_and_increment_i(): integer;
_return_a_i_and_increment_i:
	mov ip, sp
	stmfd sp!, {r4-r10, fp, ip, lr}
	mov fp, sp
@     retval := a[i];
	set r5, _i
	ldr r6, [r5]
	set r0, _a
	lsl r1, r6, #2
	add r0, r0, r1
	ldr r4, [r0]
@     i := i+1;
	add r0, r6, #1
	str r0, [r5]
@     return retval;
	mov r0, r4
	ldmfd fp, {r4-r10, fp, sp, pc}
	.ltorg

pmain:
	mov ip, sp
	stmfd sp!, {r4-r10, fp, ip, lr}
	mov fp, sp
	sub sp, sp, #8
@     a[0] := 0;
	set r4, _a
	mov r0, #0
	str r0, [r4]
@     a[1] := 1;
	mov r0, #1
	str r0, [r4, #4]
@     a[2] := 2;
	mov r0, #2
	str r0, [r4, #8]
@     a[3] := 3;
	mov r0, #3
	str r0, [r4, #12]
@     a[4] := 4;
	mov r0, #4
	str r0, [r4, #16]
@     a[5] := 5;
	mov r0, #5
	str r0, [r4, #20]
@     a[6] := 6;
	mov r0, #6
	str r0, [r4, #24]
@     a[7] := 7;
	mov r0, #7
	str r0, [r4, #28]
@     a[8] := 8;
	mov r0, #8
	str r0, [r4, #32]
@     a[9] := 9;
	mov r0, #9
	str r0, [r4, #36]
@     print_num(sum(i, 0, 9, return_a_i_and_increment_i())); newline();
	str fp, [sp]
	set r3, __anonymous_1_325145036_40930530
	mov r2, #9
	mov r1, #0
	set r0, _i
	bl _sum
	bl print_num
	bl newline
	ldmfd fp, {r4-r10, fp, sp, pc}
	.ltorg

__anonymous_1_325145036_40930530:
	mov ip, sp
	stmfd sp!, {r4-r10, fp, ip, lr}
	mov fp, sp
@ 
	bl _return_a_i_and_increment_i
	ldmfd fp, {r4-r10, fp, sp, pc}
	.ltorg

	.comm _i, 4, 4
	.comm _a, 40, 4
@ End
]]*)
\end{lstlisting}
\subsection{\textbf{\texttt{lab4/test/jensen\_function.p}}}
\begin{lstlisting}[language=pascal]
(* Jensen's device, functional application *)

var i : integer;

proc sum(var i: integer; left, right: integer; => v: integer): integer;
    var retval: integer;
begin
    retval := 0;
    i := left;
    while i <= right do
        retval := retval + v;
        i := i+1;
    end;
    return retval;
end;

begin
    print_num(sum(i, 0, 9, i * i * i * i)); newline();
end.

(*<<
15333
>>*)
(*[[
@ picoPascal compiler output
	.include "fixup.s"
	.global pmain

@ proc sum(var i: integer; left, right: integer; => v: integer): integer;
	.text
_sum:
	mov ip, sp
	stmfd sp!, {r0-r3}
	stmfd sp!, {r4-r10, fp, ip, lr}
	mov fp, sp
@     retval := 0;
	mov r4, #0
@     i := left;
	ldr r0, [fp, #44]
	ldr r1, [fp, #40]
	str r0, [r1]
.L3:
@     while i <= right do
	ldr r0, [fp, #40]
	ldr r0, [r0]
	ldr r1, [fp, #48]
	cmp r0, r1
	bgt .L5
@         retval := retval + v;
	ldr r10, [fp, #56]
	ldr r0, [fp, #52]
	blx r0
	add r4, r4, r0
@         i := i+1;
	ldr r5, [fp, #40]
	ldr r0, [r5]
	add r0, r0, #1
	str r0, [r5]
	b .L3
.L5:
@     return retval;
	mov r0, r4
	ldmfd fp, {r4-r10, fp, sp, pc}
	.ltorg

pmain:
	mov ip, sp
	stmfd sp!, {r4-r10, fp, ip, lr}
	mov fp, sp
	sub sp, sp, #8
@     print_num(sum(i, 0, 9, i * i * i * i)); newline();
	str fp, [sp]
	set r3, __anonymous_1_811043921_964796486
	mov r2, #9
	mov r1, #0
	set r0, _i
	bl _sum
	bl print_num
	bl newline
	ldmfd fp, {r4-r10, fp, sp, pc}
	.ltorg

__anonymous_1_811043921_964796486:
	mov ip, sp
	stmfd sp!, {r4-r10, fp, ip, lr}
	mov fp, sp
@ 
	set r0, _i
	ldr r4, [r0]
	mul r0, r4, r4
	mul r0, r0, r4
	mul r0, r0, r4
	ldmfd fp, {r4-r10, fp, sp, pc}
	.ltorg

	.comm _i, 4, 4
@ End
]]*)
\end{lstlisting}
\subsection{\textbf{\texttt{lab4/test/lazy\_evaluate\_by\_name.p}}}
\begin{lstlisting}[language=pascal]
(* Tests that call by name parameters are only evaluated when needed *)

proc f(=> x : integer);
begin
    print_string("hello");
    newline();
end;

proc h(var x : integer) : integer;
begin
    x := x + 1;
    return x;
end;

var x : integer;
begin
    x := 0;
    f(h(x));
    print_num(x);
    newline()
end.

(*<<
hello
0
>>*)
(*[[
@ picoPascal compiler output
	.include "fixup.s"
	.global pmain

@ proc f(=> x : integer);
	.text
_f:
	mov ip, sp
	stmfd sp!, {r0-r1}
	stmfd sp!, {r4-r10, fp, ip, lr}
	mov fp, sp
@     print_string("hello");
	mov r1, #5
	set r0, g2
	bl print_string
@     newline();
	bl newline
	ldmfd fp, {r4-r10, fp, sp, pc}
	.ltorg

@ proc h(var x : integer) : integer;
_h:
	mov ip, sp
	stmfd sp!, {r0-r1}
	stmfd sp!, {r4-r10, fp, ip, lr}
	mov fp, sp
@     x := x + 1;
	ldr r4, [fp, #40]
	ldr r0, [r4]
	add r0, r0, #1
	str r0, [r4]
@     return x;
	ldr r0, [fp, #40]
	ldr r0, [r0]
	ldmfd fp, {r4-r10, fp, sp, pc}
	.ltorg

__anonymous_1_411636619_275910739:
	mov ip, sp
	stmfd sp!, {r4-r10, fp, ip, lr}
	mov fp, sp
@ 
	set r0, _x
	bl _h
	ldmfd fp, {r4-r10, fp, sp, pc}
	.ltorg

pmain:
	mov ip, sp
	stmfd sp!, {r4-r10, fp, ip, lr}
	mov fp, sp
@     x := 0;
	set r4, _x
	mov r0, #0
	str r0, [r4]
@     f(h(x));
	mov r1, fp
	set r0, __anonymous_1_411636619_275910739
	bl _f
@     print_num(x);
	ldr r0, [r4]
	bl print_num
@     newline()
	bl newline
	ldmfd fp, {r4-r10, fp, sp, pc}
	.ltorg

	.comm _x, 4, 4
	.data
g2:
	.byte 104, 101, 108, 108, 111
	.byte 0
@ End
]]*)
\end{lstlisting}
\subsection{\textbf{\texttt{lab4/test/local\_to\_by\_name.p}}}
\begin{lstlisting}[language=pascal]
(* Tests that local variables can be passed as by-name parameters *)

proc f(=> x : integer) : integer;
begin
    return x;
end;
proc g() : integer;
    var x : integer;
begin
    x := 42;
    return f(x);
end;
var x : integer;
begin
    print_num(g());
    newline();
end.

(*<<
42
>>*)
(*[[
@ picoPascal compiler output
	.include "fixup.s"
	.global pmain

@ proc f(=> x : integer) : integer;
	.text
_f:
	mov ip, sp
	stmfd sp!, {r0-r1}
	stmfd sp!, {r4-r10, fp, ip, lr}
	mov fp, sp
@     return x;
	ldr r10, [fp, #44]
	ldr r0, [fp, #40]
	blx r0
	ldmfd fp, {r4-r10, fp, sp, pc}
	.ltorg

@ proc g() : integer;
_g:
	mov ip, sp
	stmfd sp!, {r4-r10, fp, ip, lr}
	mov fp, sp
@     x := 42;
	mov r4, #42
@     return f(x);
	mov r1, fp
	set r0, __anonymous_1_309998116_533955540
	bl _f
	ldmfd fp, {r4-r10, fp, sp, pc}
	.ltorg

pmain:
	mov ip, sp
	stmfd sp!, {r4-r10, fp, ip, lr}
	mov fp, sp
@     print_num(g());
	bl _g
	bl print_num
@     newline();
	bl newline
	ldmfd fp, {r4-r10, fp, sp, pc}
	.ltorg

__anonymous_1_309998116_533955540:
	mov ip, sp
	stmfd sp!, {r4-r10, fp, ip, lr}
	mov fp, sp
@ 
	mov r0, r4
	ldmfd fp, {r4-r10, fp, sp, pc}
	.ltorg

	.comm _x, 4, 4
@ End
]]*)
\end{lstlisting}
\subsection{\textbf{\texttt{lab4/test/multiple\_continues.p}}}
\begin{lstlisting}[language=pascal]
(* multiple continue statements in a single loop *)

var i : integer;
begin
    for i := 1 to 20 do;
        if i mod 2 = 0 then continue else end;
        if i mod 3 = 0 then continue else end;
        if i mod 5 = 0 then continue else end;
        print_num(i);
        print_char(' ')
    end;
    newline()
end.

(*<<
1 7 11 13 17 19 
>>*)
(*[[
@ picoPascal compiler output
	.include "fixup.s"
	.global pmain

	.text
pmain:
	mov ip, sp
	stmfd sp!, {r4-r10, fp, ip, lr}
	mov fp, sp
@     for i := 1 to 20 do;
	mov r0, #1
	set r1, _i
	str r0, [r1]
	mov r4, #20
.L3:
	set r5, _i
	ldr r6, [r5]
	cmp r6, r4
	bgt .L4
@         if i mod 2 = 0 then continue else end;
	mov r1, #2
	mov r0, r6
	bl int_mod
	cmp r0, #0
	beq .L5
@         if i mod 3 = 0 then continue else end;
	mov r1, #3
	ldr r0, [r5]
	bl int_mod
	cmp r0, #0
	beq .L5
@         if i mod 5 = 0 then continue else end;
	mov r1, #5
	ldr r0, [r5]
	bl int_mod
	cmp r0, #0
	beq .L5
@         print_num(i);
	ldr r0, [r5]
	bl print_num
@         print_char(' ')
	mov r0, #32
	bl print_char
.L5:
	set r5, _i
	ldr r0, [r5]
	add r0, r0, #1
	str r0, [r5]
	b .L3
.L4:
@     newline()
	bl newline
	ldmfd fp, {r4-r10, fp, sp, pc}
	.ltorg

	.comm _i, 4, 4
@ End
]]*)
\end{lstlisting}
\subsection{\textbf{\texttt{lab4/test/nested\_continue.p}}}
\begin{lstlisting}[language=pascal]
(* a test designed to make sure that we jump to the end of the correct loop *)

var i, j : integer;
begin
    for i := 1 to 4 do;
        if i mod 3 = 0 then continue end;
        for j := 1 to 4 do;
            if (i + j) mod 2 = 0 then continue end;
            print_num(i);
            print_char(' ');
            print_num(j);
            newline()
        end
    end
end.

(*<<
1 2
1 4
2 1
2 3
4 1
4 3
>>*)
(*[[
@ picoPascal compiler output
	.include "fixup.s"
	.global pmain

	.text
pmain:
	mov ip, sp
	stmfd sp!, {r4-r10, fp, ip, lr}
	mov fp, sp
@     for i := 1 to 4 do;
	mov r0, #1
	set r1, _i
	str r0, [r1]
	mov r5, #4
.L3:
	set r0, _i
	ldr r6, [r0]
	cmp r6, r5
	bgt .L2
@         if i mod 3 = 0 then continue end;
	mov r1, #3
	mov r0, r6
	bl int_mod
	cmp r0, #0
	beq .L5
@         for j := 1 to 4 do;
	mov r0, #1
	set r1, _j
	str r0, [r1]
	mov r4, #4
.L9:
	set r6, _j
	ldr r7, [r6]
	cmp r7, r4
	bgt .L5
@             if (i + j) mod 2 = 0 then continue end;
	set r8, _i
	mov r1, #2
	ldr r0, [r8]
	add r0, r0, r7
	bl int_mod
	cmp r0, #0
	beq .L11
@             print_num(i);
	ldr r0, [r8]
	bl print_num
@             print_char(' ');
	mov r0, #32
	bl print_char
@             print_num(j);
	ldr r0, [r6]
	bl print_num
@             newline()
	bl newline
.L11:
	set r6, _j
	ldr r0, [r6]
	add r0, r0, #1
	str r0, [r6]
	b .L9
.L5:
	set r6, _i
	ldr r0, [r6]
	add r0, r0, #1
	str r0, [r6]
	b .L3
.L2:
	ldmfd fp, {r4-r10, fp, sp, pc}
	.ltorg

	.comm _i, 4, 4
	.comm _j, 4, 4
@ End
]]*)
\end{lstlisting}
\subsection{\textbf{\texttt{lab4/test/reevaluate\_by\_name.p}}}
\begin{lstlisting}[language=pascal]
(* Tests that call by name parameters are re-evaluated each time they are used *)

proc f(=> x : integer);
begin
    print_num(x);
    newline();
    print_num(x);
    newline();
end;

proc h(var x : integer) : integer;
begin
    x := x + 1;
    return x;
end;

var x : integer;
begin
    x := 0;
    f(h(x));
end.

(*<<
1
2
>>*)
(*[[
@ picoPascal compiler output
	.include "fixup.s"
	.global pmain

@ proc f(=> x : integer);
	.text
_f:
	mov ip, sp
	stmfd sp!, {r0-r1}
	stmfd sp!, {r4-r10, fp, ip, lr}
	mov fp, sp
@     print_num(x);
	ldr r10, [fp, #44]
	ldr r0, [fp, #40]
	blx r0
	bl print_num
@     newline();
	bl newline
@     print_num(x);
	ldr r10, [fp, #44]
	ldr r0, [fp, #40]
	blx r0
	bl print_num
@     newline();
	bl newline
	ldmfd fp, {r4-r10, fp, sp, pc}
	.ltorg

@ proc h(var x : integer) : integer;
_h:
	mov ip, sp
	stmfd sp!, {r0-r1}
	stmfd sp!, {r4-r10, fp, ip, lr}
	mov fp, sp
@     x := x + 1;
	ldr r4, [fp, #40]
	ldr r0, [r4]
	add r0, r0, #1
	str r0, [r4]
@     return x;
	ldr r0, [fp, #40]
	ldr r0, [r0]
	ldmfd fp, {r4-r10, fp, sp, pc}
	.ltorg

__anonymous_1_677024997_176975751:
	mov ip, sp
	stmfd sp!, {r4-r10, fp, ip, lr}
	mov fp, sp
@ 
	set r0, _x
	bl _h
	ldmfd fp, {r4-r10, fp, sp, pc}
	.ltorg

pmain:
	mov ip, sp
	stmfd sp!, {r4-r10, fp, ip, lr}
	mov fp, sp
@     x := 0;
	mov r0, #0
	set r1, _x
	str r0, [r1]
@     f(h(x));
	mov r1, fp
	set r0, __anonymous_1_677024997_176975751
	bl _f
	ldmfd fp, {r4-r10, fp, sp, pc}
	.ltorg

	.comm _x, 4, 4
@ End
]]*)
\end{lstlisting}
\subsection{\textbf{\texttt{lab4/test/repeat\_continue.p}}}
\begin{lstlisting}[language=pascal]
(* A continue statement inside a while loop *)

var i: integer;
begin
    i := 0;
    repeat
        i := i+1;
        if i mod 2 = 0 then continue end;
        print_num(i);
        print_char(' ')
    until i >= 100;
    newline()
end.

(*<<
1 3 5 7 9 11 13 15 17 19 21 23 25 27 29 31 33 35 37 39 41 43 45 47 49 51 53 55 57 59 61 63 65 67 69 71 73 75 77 79 81 83 85 87 89 91 93 95 97 99 
>>*)
(*[[
@ picoPascal compiler output
	.include "fixup.s"
	.global pmain

	.text
pmain:
	mov ip, sp
	stmfd sp!, {r4-r10, fp, ip, lr}
	mov fp, sp
@     i := 0;
	mov r0, #0
	set r1, _i
	str r0, [r1]
.L3:
@         i := i+1;
	set r4, _i
	ldr r0, [r4]
	add r5, r0, #1
	str r5, [r4]
@         if i mod 2 = 0 then continue end;
	mov r1, #2
	mov r0, r5
	bl int_mod
	cmp r0, #0
	beq .L5
@         print_num(i);
	ldr r0, [r4]
	bl print_num
@         print_char(' ')
	mov r0, #32
	bl print_char
.L5:
	set r0, _i
	ldr r0, [r0]
	cmp r0, #100
	blt .L3
@     newline()
	bl newline
	ldmfd fp, {r4-r10, fp, sp, pc}
	.ltorg

	.comm _i, 4, 4
@ End
]]*)
\end{lstlisting}
\subsection{\textbf{\texttt{lab4/test/rightarrow\_non\_int\_error.p}}}
\begin{lstlisting}[language=pascal]
(* a test to check that only integers can be call by name parameters *)

type arr = array 10 of integer;

proc f(=> x : arr) : integer;
begin
    return x[2];
end;
var x : arr;
begin
    x[2] := 1;
    print_num(f(x));
    newline()
end.

(*<<
"test/rightarrow_non_int_error.p", line 5: Call by name parameter must be an integer
>>*)
(*[[
]]*)
\end{lstlisting}
\subsection{\textbf{\texttt{lab4/test/rightarrow\_same\_as\_var.p}}}
\begin{lstlisting}[language=pascal]
proc f(=> x, y : integer) : integer;
begin
    return x + y;
end;
begin
    print_num(f(1, 2));
    newline()
end.

(*<<
3
>>*)
(*[[
@ picoPascal compiler output
	.include "fixup.s"
	.global pmain

@ proc f(=> x, y : integer) : integer;
	.text
_f:
	mov ip, sp
	stmfd sp!, {r0-r3}
	stmfd sp!, {r4-r10, fp, ip, lr}
	mov fp, sp
@     return x + y;
	ldr r10, [fp, #44]
	ldr r0, [fp, #40]
	blx r0
	ldr r10, [fp, #52]
	mov r4, r0
	ldr r0, [fp, #48]
	blx r0
	add r0, r4, r0
	ldmfd fp, {r4-r10, fp, sp, pc}
	.ltorg

__anonymous_1_183208200_185317741:
	mov ip, sp
	stmfd sp!, {r4-r10, fp, ip, lr}
	mov fp, sp
@ 
	mov r0, #1
	ldmfd fp, {r4-r10, fp, sp, pc}
	.ltorg

__anonymous_2_963940343_122039775:
	mov ip, sp
	stmfd sp!, {r4-r10, fp, ip, lr}
	mov fp, sp
	mov r0, #2
	ldmfd fp, {r4-r10, fp, sp, pc}
	.ltorg

pmain:
	mov ip, sp
	stmfd sp!, {r4-r10, fp, ip, lr}
	mov fp, sp
@     print_num(f(1, 2));
	mov r3, fp
	set r2, __anonymous_2_963940343_122039775
	mov r1, fp
	set r0, __anonymous_1_183208200_185317741
	bl _f
	bl print_num
@     newline()
	bl newline
	ldmfd fp, {r4-r10, fp, sp, pc}
	.ltorg

@ End
]]*)
\end{lstlisting}
\subsection{\textbf{\texttt{lab4/test/while\_continue.p}}}
\begin{lstlisting}[language=pascal]
(* A continue statement inside a while loop *)

var i: integer;
begin
    i := 0;
    while i < 100 do
        i := i+1;
        if i mod 2 = 0 then continue end;
        print_num(i);
        print_char(' ')
    end;
    newline()
end.

(*<<
1 3 5 7 9 11 13 15 17 19 21 23 25 27 29 31 33 35 37 39 41 43 45 47 49 51 53 55 57 59 61 63 65 67 69 71 73 75 77 79 81 83 85 87 89 91 93 95 97 99 
>>*)
(*[[
@ picoPascal compiler output
	.include "fixup.s"
	.global pmain

	.text
pmain:
	mov ip, sp
	stmfd sp!, {r4-r10, fp, ip, lr}
	mov fp, sp
@     i := 0;
	mov r0, #0
	set r1, _i
	str r0, [r1]
.L3:
@     while i < 100 do
	set r4, _i
	ldr r5, [r4]
	cmp r5, #100
	bge .L5
@         i := i+1;
	add r5, r5, #1
	str r5, [r4]
@         if i mod 2 = 0 then continue end;
	mov r1, #2
	mov r0, r5
	bl int_mod
	cmp r0, #0
	beq .L3
@         print_num(i);
	ldr r0, [r4]
	bl print_num
@         print_char(' ')
	mov r0, #32
	bl print_char
	b .L3
.L5:
@     newline()
	bl newline
	ldmfd fp, {r4-r10, fp, sp, pc}
	.ltorg

	.comm _i, 4, 4
@ End
]]*)
\end{lstlisting}
