/* Instruction interpreter -- generated by iset.tcl */

/*
 * iskel.c
 * 
 * This file is part of the Oxford Oberon-2 compiler
 * Copyright (c) 2006--2016 J. M. Spivey
 * All rights reserved
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/* This file is the skeleton of the bytecode interpreter; the parts
   specific to each instruction are inserted from the file
   'keiko.iset' by the script 'iset.tcl'.  There are three places that
   code is inserted, each marked by two dollar signs.  In order of
   appearance, they are:

   1. A jump table for quick dispatching (used if JTABLE is defined).

   2. Macro definitions used in the action routines.

   3. Action routines for each instruction, forming the cases in a big
      switch. */

#include <math.h>
#include "obx.h"
#include "keiko.h"

#ifdef HAVE_INDEXED_JUMPS
#define JTABLE 1
#endif

#ifdef TRACE
#define DISASS 1
#undef JTABLE
#define do_find_proc if (dflag > 1) thisproc = find_proc(cp)
#else
#define do_find_proc
#endif

#ifdef PROFILE
#undef JTABLE
#endif


#define local(n)        ((uchar *) bp + (n))
#define parent(a, t)    indir(pointer(bp[SL]) + a, t)
#define indir(p, t)     (* (t *) (p))
#define subs(p, n, t)   ((t *) (p))[n]
#define const(n)        cp[CP_CONST+n]
#define jump(lab)       pc = pc0 + lab


#define dup(n, sp)      sp--; sp[0] = sp[n+1]
#define swap(sp)        sp[-1] = sp[1]; sp[1] = sp[0]; sp[0] = sp[-1]


#define ror(a, b) ((((unsigned) a) >> b) | (((unsigned) a) << (32-b)))


/* The DIV and MOD instructions must give the correct results, even if 
   C is wrong.  Correct means that b * (a DIV b) + a MOD b = a, and 
   (-a) DIV (-b) = a DIV b, and if b > 0 then 0 <= a MOD b < b. */

static inline divop_decl(int)
static inline divop_decl(longint)


#define jcase(x, n)  if ((unsigned) x < (unsigned) n) { pc0 = pc + 2*x; jump(get2(pc0)); }  else pc += 2*n


static inline int fcmpl(double a, double b) {
     return (a > b ? 1 : a == b ? 0 : -1);
}

static inline int fcmpg(double a, double b) {
     return (a < b ? -1 : a == b ? 0 : 1);
}

static inline int lcmp(longint a, longint b) {
     return (a < b ? -1 : a > b ? 1 : 0);
}


#ifdef UNALIGNED_MEM
#define getdbl get_double
#define putdbl put_double
#define getlong get_long
#define putlong put_long
#else
static inline double getdbl(value *v) {
     dblbuf dd;
     dd.n.lo = v[0].i;
     dd.n.hi = v[1].i;
     return dd.d;
}

static inline void putdbl(value *v, double x) {
     dblbuf dd;
     dd.d = x;
     v[0].i = dd.n.lo;
     v[1].i = dd.n.hi;
}

static inline longint getlong(value *v) {
     dblbuf dd;
     dd.n.lo = v[0].i;
     dd.n.hi = v[1].i;
     return dd.q;
}

static inline void putlong(value *v, longint x) {
     dblbuf dd;
     dd.q = x;
     v[0].i = dd.n.lo;
     v[1].i = dd.n.hi;
}
#endif


static inline int boundcheck(unsigned i, unsigned n, int line,               
                             value *bp, uchar *pc) {         
     if (i >= n) runtime_error(E_BOUND, line, bp, pc);
     return i;                                               
}

#define checkdef(name, type, arg, extra, test, msg)                      static inline type name(type arg extra, int line,                       value *bp, uchar *pc) {                         if (test) runtime_error(msg, line, bp, pc);                     return arg;                                                     }

checkdef(nullcheck, uchar *, p,, p == NULL, E_NULL)
checkdef(zerocheck, int, n,, n == 0, E_DIV)
checkdef(fzerocheck, double, x,, x == 0.0, E_FDIV)
checkdef(lzerocheck, longint, n,, n == 0, E_DIV)
checkdef(globcheck, value *, p,, p != NULL, E_GLOB)

#define czech(chk, a, n) chk(a, n, bp, pc0)
#define czech2(chk, a, b, n) chk(a, b, n, bp, pc0)
#define error(msg, n) runtime_error(msg, n, bp, pc0);


#ifdef WORDS_BIGENDIAN
#define alignx(a, n)    (a <<= (32-n))
#else
#define alignx(a, n)    a
#endif


#ifdef PROFILE
#define prof_charge(n)  ticks += n
#else
#define prof_charge(n)
#endif


#define fixcopy(a, b, n) prof_charge(n/4); memcpy(a, b, n)


#define flexcopy(d0, size0)                                              { value *d = (value *) d0; int size = size0;                    int sizew = (size+3)/4; prof_charge(sizew);                     sp -= sizew;                                                    if ((uchar *) sp < stack + SLIMIT)                              error(E_STACK, 0);                                              memcpy(sp, pointer(d[0]), size);                                        d[0].a = address(sp);}


#define frame()                                                          bp = sp;                                                                sp = (value *) ((uchar *) bp - cp[CP_FRAME].i);                         if ((uchar *) sp < stack + SLIMIT) error(E_STACK, 0);           memset(sp, 0, cp[CP_FRAME].i);

#ifdef OBXDEB
#define cond_break()  if (one_shot && *pc != K_LNUM_2 && *pc != K_BREAK_2)  debug_break(cp, bp, pc, "stop")
#else
#define cond_break()
#endif


#define slide(nargs) sp += HEAD + nargs; cond_break();


#define casejump(x, n0)                                  {                                                       int n = n0;                                     pc0 = pc; pc += 4*n;                            while (n > 0) {                                 if (x == get2(pc0)) {                   jump(get2(pc0+2));                      break;                          }                                       pc0 += 4; n--;                          }                                               }



/* interp -- main loop of the interpreter */
void interp(value *sp0) {
     register value *cp = valptr(sp0[CP]);
     uchar *pc = pointer(cp[CP_CODE]);
     register uchar *pc0 = NULL;
     register value *sp = sp0;
     register uchar ir = 0;
#ifdef PROFILE
     register counter ticks = 0;
#endif
     register value *bp = NULL;
     value *base = sp0;
#ifdef TRACE
     proc thisproc = NULL;
#endif

#ifdef JTABLE
     /* Save time by using gcc's label array feature */
     static void *jtable[256] = {
          &&lbl_ILLEGAL,
          &&lbl_PUSH_x1,
          &&lbl_PUSH_x1,
          &&lbl_PUSH_x1,
          &&lbl_PUSH_x1,
          &&lbl_PUSH_x1,
          &&lbl_PUSH_x1,
          &&lbl_PUSH_x1,
          &&lbl_PUSH_x1,
          &&lbl_PUSH_1,
          &&lbl_PUSH_2,
          &&lbl_LDKW_1,
          &&lbl_LDKW_2,
          &&lbl_LDKF_1,
          &&lbl_LDKF_2,
          &&lbl_LOCAL_1,
          &&lbl_LOCAL_2,
          &&lbl_OFFSET,
          &&lbl_INDEXS,
          &&lbl_INDEXW,
          &&lbl_INDEXD,
          &&lbl_LOADW,
          &&lbl_LOADS,
          &&lbl_LOADC,
          &&lbl_LOADF,
          &&lbl_STOREW,
          &&lbl_STORES,
          &&lbl_STOREC,
          &&lbl_STOREF,
          &&lbl_LDLW_x1,
          &&lbl_LDLW_x1,
          &&lbl_LDLW_x1,
          &&lbl_LDLW_x1,
          &&lbl_LDLW_x1,
          &&lbl_LDLW_x1,
          &&lbl_LDLW_x2,
          &&lbl_LDLW_x2,
          &&lbl_LDLW_x2,
          &&lbl_LDLW_x2,
          &&lbl_LDLW_x2,
          &&lbl_LDLW_x2,
          &&lbl_LDLW_1,
          &&lbl_LDLW_2,
          &&lbl_LDLS_1,
          &&lbl_LDLS_2,
          &&lbl_LDLC_1,
          &&lbl_LDLC_2,
          &&lbl_LDLF_1,
          &&lbl_LDLF_2,
          &&lbl_STLW_x1,
          &&lbl_STLW_x1,
          &&lbl_STLW_x1,
          &&lbl_STLW_x1,
          &&lbl_STLW_x1,
          &&lbl_STLW_x1,
          &&lbl_STLW_x2,
          &&lbl_STLW_x2,
          &&lbl_STLW_x2,
          &&lbl_STLW_x2,
          &&lbl_STLW_x2,
          &&lbl_STLW_x2,
          &&lbl_STLW_1,
          &&lbl_STLW_2,
          &&lbl_STLS_1,
          &&lbl_STLS_2,
          &&lbl_STLC_1,
          &&lbl_STLC_2,
          &&lbl_STLF_1,
          &&lbl_STLF_2,
          &&lbl_LDGW_K,
          &&lbl_LDGW_L,
          &&lbl_LDGS_K,
          &&lbl_LDGS_L,
          &&lbl_LDGC_K,
          &&lbl_LDGC_L,
          &&lbl_LDGF_K,
          &&lbl_LDGF_L,
          &&lbl_STGW_K,
          &&lbl_STGW_L,
          &&lbl_STGS_K,
          &&lbl_STGS_L,
          &&lbl_STGC_K,
          &&lbl_STGC_L,
          &&lbl_STGF_K,
          &&lbl_STGF_L,
          &&lbl_LDNW_x1,
          &&lbl_LDNW_x1,
          &&lbl_LDNW_x1,
          &&lbl_LDNW_x1,
          &&lbl_LDNW_x1,
          &&lbl_LDNW_x1,
          &&lbl_LDNW_x1,
          &&lbl_LDNW_x1,
          &&lbl_LDNW_x1,
          &&lbl_LDNW_x1,
          &&lbl_LDNW_x1,
          &&lbl_LDNW_x1,
          &&lbl_LDNW_x1,
          &&lbl_LDNW_x1,
          &&lbl_LDNW_x1,
          &&lbl_LDNW_1,
          &&lbl_LDNW_2,
          &&lbl_STNW_x1,
          &&lbl_STNW_x1,
          &&lbl_STNW_x1,
          &&lbl_STNW_x1,
          &&lbl_STNW_x1,
          &&lbl_STNW_x1,
          &&lbl_STNW_x1,
          &&lbl_STNW_x1,
          &&lbl_STNW_x1,
          &&lbl_STNW_x1,
          &&lbl_STNW_1,
          &&lbl_STNW_2,
          &&lbl_LDIW,
          &&lbl_LDIF,
          &&lbl_LDIS,
          &&lbl_LDIC,
          &&lbl_STIW,
          &&lbl_STIF,
          &&lbl_STIS,
          &&lbl_STIC,
          &&lbl_LDID,
          &&lbl_STID,
          &&lbl_LDIQ,
          &&lbl_STIQ,
          &&lbl_LOADD,
          &&lbl_STORED,
          &&lbl_LDKD_1,
          &&lbl_LDKD_2,
          &&lbl_LOADQ,
          &&lbl_STOREQ,
          &&lbl_LDKQ_1,
          &&lbl_LDKQ_2,
          &&lbl_INCL_1,
          &&lbl_DECL_1,
          &&lbl_DUP,
          &&lbl_DUP,
          &&lbl_DUP,
          &&lbl_SWAP,
          &&lbl_POP_1,
          &&lbl_PLUS,
          &&lbl_MINUS,
          &&lbl_TIMES,
          &&lbl_UMINUS,
          &&lbl_AND,
          &&lbl_OR,
          &&lbl_NOT,
          &&lbl_INC,
          &&lbl_DEC,
          &&lbl_BITAND,
          &&lbl_BITOR,
          &&lbl_BITXOR,
          &&lbl_BITNOT,
          &&lbl_LSL,
          &&lbl_LSR,
          &&lbl_ASR,
          &&lbl_ROR,
          &&lbl_DIV,
          &&lbl_MOD,
          &&lbl_EQ,
          &&lbl_LT,
          &&lbl_GT,
          &&lbl_LEQ,
          &&lbl_GEQ,
          &&lbl_NEQ,
          &&lbl_JEQ_S,
          &&lbl_JEQ_R,
          &&lbl_JLT_S,
          &&lbl_JLT_R,
          &&lbl_JGT_S,
          &&lbl_JGT_R,
          &&lbl_JLEQ_S,
          &&lbl_JLEQ_R,
          &&lbl_JGEQ_S,
          &&lbl_JGEQ_R,
          &&lbl_JNEQ_S,
          &&lbl_JNEQ_R,
          &&lbl_JLTZ_S,
          &&lbl_JGTZ_S,
          &&lbl_JLEQZ_S,
          &&lbl_JGEQZ_S,
          &&lbl_JNEQZ_S,
          &&lbl_JNEQZ_R,
          &&lbl_JEQZ_S,
          &&lbl_JEQZ_R,
          &&lbl_JUMP_S,
          &&lbl_JUMP_R,
          &&lbl_QPLUS,
          &&lbl_QMINUS,
          &&lbl_QTIMES,
          &&lbl_QUMINUS,
          &&lbl_QDIV,
          &&lbl_QMOD,
          &&lbl_JCASE_1,
          &&lbl_JRANGE_S,
          &&lbl_JRANGE_R,
          &&lbl_TESTGEQ_S,
          &&lbl_TESTGEQ_R,
          &&lbl_FPLUS,
          &&lbl_FMINUS,
          &&lbl_FTIMES,
          &&lbl_FDIV,
          &&lbl_FUMINUS,
          &&lbl_FCMPL,
          &&lbl_FCMPG,
          &&lbl_DPLUS,
          &&lbl_DMINUS,
          &&lbl_DTIMES,
          &&lbl_DDIV,
          &&lbl_DUMINUS,
          &&lbl_DCMPL,
          &&lbl_DCMPG,
          &&lbl_QCMP,
          &&lbl_CONVNF,
          &&lbl_CONVND,
          &&lbl_CONVFN,
          &&lbl_CONVDN,
          &&lbl_CONVFD,
          &&lbl_CONVDF,
          &&lbl_CONVNC,
          &&lbl_CONVNS,
          &&lbl_CONVNQ,
          &&lbl_CONVQN,
          &&lbl_CONVQD,
          &&lbl_BOUND_2,
          &&lbl_NCHECK_2,
          &&lbl_GCHECK_2,
          &&lbl_ZCHECK_2,
          &&lbl_FZCHECK_2,
          &&lbl_DZCHECK_2,
          &&lbl_QZCHECK_2,
          &&lbl_ERROR_12,
          &&lbl_ALIGNC,
          &&lbl_ALIGNS,
          &&lbl_FIXCOPY,
          &&lbl_FLEXCOPY,
          &&lbl_LINK,
          &&lbl_SAVELINK,
          &&lbl_JPROC,
          &&lbl_SLIDE_1,
          &&lbl_SLIDEW_1,
          &&lbl_SLIDED_1,
          &&lbl_SLIDEF_1,
          &&lbl_SLIDEQ_1,
          &&lbl_RESULTW,
          &&lbl_RESULTD,
          &&lbl_RESULTF,
          &&lbl_RESULTQ,
          &&lbl_RETURN,
          &&lbl_LNUM_2,
          &&lbl_BREAK_2,
          &&lbl_CASEJUMP_1,
          &&lbl_PACK,
          &&lbl_UNPACK,
          &&lbl_ILLEGAL,
     };
#endif

#ifdef JTABLE
/* Each action ends with an indexed jump to the next */
#define ACTION(op) lbl_ ## op:
#define ALSO(op)
#define DEFAULT
#define NEXT       goto *jtable[ir = *(pc0 = pc)]
#else
/* Actions are just cases in a big switch */
#define ACTION(op) case K_ ## op:
#define ALSO(op)   case K_ ## op:
#define DEFAULT    default:
#define NEXT       break
#endif

     level++;
     do_find_proc;

#ifdef PROFILE
     prof_enter(cp, 0, PROF_CALL);
#endif

     frame();

#ifdef JTABLE
     NEXT;
#else
     while (TRUE) {
#ifdef TRACE
          if (dflag > 1) {
               printf("pc=%s+%ld(%p) sp=%p bp=%p cp=%p",
                      thisproc->p_name,
                      (long) (pc - (uchar *) pointer(cp[CP_CODE])),
                      pc, sp, bp, cp);
               fflush(stdout);
               for (int i = 0; i < 8; i++) printf(" %x", sp[i].i);
               printf("\n");
               printf("%6ld: %s\n", (long) (pc-imem), fmt_inst(pc));
               fflush(stdout);
          }
#endif

#ifdef PROFILE
          ticks++;
#endif

          switch (ir = *(pc0 = pc)) {
#endif

          ACTION(PUSH_x1)
          ALSO(PUSH_x1+1)
          ALSO(PUSH_x1+2)
          ALSO(PUSH_x1+3)
          ALSO(PUSH_x1+4)
          ALSO(PUSH_x1+5)
          ALSO(PUSH_x1+6)
          ALSO(PUSH_x1+7)
               pc = pc0 + 1;
               sp--; sp[0].i = ir-2;
               NEXT;

          ACTION(PUSH_1)
               pc = pc0 + 2;
               sp--; sp[0].i = get1(pc0+1);
               NEXT;

          ACTION(PUSH_2)
               pc = pc0 + 3;
               sp--; sp[0].i = get2(pc0+1);
               NEXT;

          ACTION(LDKW_1)
               pc = pc0 + 2;
               sp--; sp[0].i = const(get1(pc0+1)).i;
               NEXT;

          ACTION(LDKW_2)
               pc = pc0 + 3;
               sp--; sp[0].i = const(get2(pc0+1)).i;
               NEXT;

          ACTION(LDKF_1)
               pc = pc0 + 2;
               sp--; sp[0].f = const(get1(pc0+1)).f;
               NEXT;

          ACTION(LDKF_2)
               pc = pc0 + 3;
               sp--; sp[0].f = const(get2(pc0+1)).f;
               NEXT;

          ACTION(LOCAL_1)
               pc = pc0 + 2;
               sp--; sp[0].a = address(local(get1(pc0+1)));
               NEXT;

          ACTION(LOCAL_2)
               pc = pc0 + 3;
               sp--; sp[0].a = address(local(get2(pc0+1)));
               NEXT;

          ACTION(OFFSET)
               pc = pc0 + 1;
               sp++; sp[0].a = address(pointer(sp[0]) + sp[-1].i);
               NEXT;

          ACTION(INDEXS)
               pc = pc0 + 1;
               sp++; sp[0].a = address(pointer(sp[0]) + (sp[-1].i<<1));
               NEXT;

          ACTION(INDEXW)
               pc = pc0 + 1;
               sp++; sp[0].a = address(pointer(sp[0]) + (sp[-1].i<<2));
               NEXT;

          ACTION(INDEXD)
               pc = pc0 + 1;
               sp++; sp[0].a = address(pointer(sp[0]) + (sp[-1].i<<3));
               NEXT;

          ACTION(LOADW)
               pc = pc0 + 1;
               sp[0].i = indir(pointer(sp[0]), int);
               NEXT;

          ACTION(LOADS)
               pc = pc0 + 1;
               sp[0].i = indir(pointer(sp[0]), short);
               NEXT;

          ACTION(LOADC)
               pc = pc0 + 1;
               sp[0].i = indir(pointer(sp[0]), uchar);
               NEXT;

          ACTION(LOADF)
               pc = pc0 + 1;
               sp[0].f = indir(pointer(sp[0]), float);
               NEXT;

          ACTION(STOREW)
               pc = pc0 + 1;
               sp += 2; { indir(pointer(sp[-2]), int) = sp[-1].i; }
               NEXT;

          ACTION(STORES)
               pc = pc0 + 1;
               sp += 2; { indir(pointer(sp[-2]), short) = sp[-1].i; }
               NEXT;

          ACTION(STOREC)
               pc = pc0 + 1;
               sp += 2; { indir(pointer(sp[-2]), uchar) = sp[-1].i; }
               NEXT;

          ACTION(STOREF)
               pc = pc0 + 1;
               sp += 2; { indir(pointer(sp[-2]), float) = sp[-1].f; }
               NEXT;

          ACTION(LDLW_x1)
          ALSO(LDLW_x1+1)
          ALSO(LDLW_x1+2)
          ALSO(LDLW_x1+3)
          ALSO(LDLW_x1+4)
          ALSO(LDLW_x1+5)
               pc = pc0 + 1;
               sp--; sp[0].i = indir(local(ir*4-140), int);
               NEXT;

          ACTION(LDLW_x2)
          ALSO(LDLW_x2+1)
          ALSO(LDLW_x2+2)
          ALSO(LDLW_x2+3)
          ALSO(LDLW_x2+4)
          ALSO(LDLW_x2+5)
               pc = pc0 + 1;
               sp--; sp[0].i = indir(local(ir*4-128), int);
               NEXT;

          ACTION(LDLW_1)
               pc = pc0 + 2;
               sp--; sp[0].i = indir(local(get1(pc0+1)), int);
               NEXT;

          ACTION(LDLW_2)
               pc = pc0 + 3;
               sp--; sp[0].i = indir(local(get2(pc0+1)), int);
               NEXT;

          ACTION(LDLS_1)
               pc = pc0 + 2;
               sp--; sp[0].i = indir(local(get1(pc0+1)), short);
               NEXT;

          ACTION(LDLS_2)
               pc = pc0 + 3;
               sp--; sp[0].i = indir(local(get2(pc0+1)), short);
               NEXT;

          ACTION(LDLC_1)
               pc = pc0 + 2;
               sp--; sp[0].i = indir(local(get1(pc0+1)), uchar);
               NEXT;

          ACTION(LDLC_2)
               pc = pc0 + 3;
               sp--; sp[0].i = indir(local(get2(pc0+1)), uchar);
               NEXT;

          ACTION(LDLF_1)
               pc = pc0 + 2;
               sp--; sp[0].f = indir(local(get1(pc0+1)), float);
               NEXT;

          ACTION(LDLF_2)
               pc = pc0 + 3;
               sp--; sp[0].f = indir(local(get2(pc0+1)), float);
               NEXT;

          ACTION(STLW_x1)
          ALSO(STLW_x1+1)
          ALSO(STLW_x1+2)
          ALSO(STLW_x1+3)
          ALSO(STLW_x1+4)
          ALSO(STLW_x1+5)
               pc = pc0 + 1;
               sp += 1; { indir(local(ir*4-220), int) = sp[-1].i; }
               NEXT;

          ACTION(STLW_x2)
          ALSO(STLW_x2+1)
          ALSO(STLW_x2+2)
          ALSO(STLW_x2+3)
          ALSO(STLW_x2+4)
          ALSO(STLW_x2+5)
               pc = pc0 + 1;
               sp += 1; { indir(local(ir*4-208), int) = sp[-1].i; }
               NEXT;

          ACTION(STLW_1)
               pc = pc0 + 2;
               sp += 1; { indir(local(get1(pc0+1)), int) = sp[-1].i; }
               NEXT;

          ACTION(STLW_2)
               pc = pc0 + 3;
               sp += 1; { indir(local(get2(pc0+1)), int) = sp[-1].i; }
               NEXT;

          ACTION(STLS_1)
               pc = pc0 + 2;
               sp += 1; { indir(local(get1(pc0+1)), short) = sp[-1].i; }
               NEXT;

          ACTION(STLS_2)
               pc = pc0 + 3;
               sp += 1; { indir(local(get2(pc0+1)), short) = sp[-1].i; }
               NEXT;

          ACTION(STLC_1)
               pc = pc0 + 2;
               sp += 1; { indir(local(get1(pc0+1)), uchar) = sp[-1].i; }
               NEXT;

          ACTION(STLC_2)
               pc = pc0 + 3;
               sp += 1; { indir(local(get2(pc0+1)), uchar) = sp[-1].i; }
               NEXT;

          ACTION(STLF_1)
               pc = pc0 + 2;
               sp += 1; { indir(local(get1(pc0+1)), float) = sp[-1].f; }
               NEXT;

          ACTION(STLF_2)
               pc = pc0 + 3;
               sp += 1; { indir(local(get2(pc0+1)), float) = sp[-1].f; }
               NEXT;

          ACTION(LDGW_K)
               pc = pc0 + 2;
               sp--; sp[0].i = indir(pointer(const(get1(pc0+1))), int);
               NEXT;

          ACTION(LDGW_L)
               pc = pc0 + 3;
               sp--; sp[0].i = indir(pointer(const(get2(pc0+1))), int);
               NEXT;

          ACTION(LDGS_K)
               pc = pc0 + 2;
               sp--; sp[0].i = indir(pointer(const(get1(pc0+1))), short);
               NEXT;

          ACTION(LDGS_L)
               pc = pc0 + 3;
               sp--; sp[0].i = indir(pointer(const(get2(pc0+1))), short);
               NEXT;

          ACTION(LDGC_K)
               pc = pc0 + 2;
               sp--; sp[0].i = indir(pointer(const(get1(pc0+1))), uchar);
               NEXT;

          ACTION(LDGC_L)
               pc = pc0 + 3;
               sp--; sp[0].i = indir(pointer(const(get2(pc0+1))), uchar);
               NEXT;

          ACTION(LDGF_K)
               pc = pc0 + 2;
               sp--; sp[0].f = indir(pointer(const(get1(pc0+1))), float);
               NEXT;

          ACTION(LDGF_L)
               pc = pc0 + 3;
               sp--; sp[0].f = indir(pointer(const(get2(pc0+1))), float);
               NEXT;

          ACTION(STGW_K)
               pc = pc0 + 2;
               sp += 1; { indir(pointer(const(get1(pc0+1))), int) = sp[-1].i; }
               NEXT;

          ACTION(STGW_L)
               pc = pc0 + 3;
               sp += 1; { indir(pointer(const(get2(pc0+1))), int) = sp[-1].i; }
               NEXT;

          ACTION(STGS_K)
               pc = pc0 + 2;
               sp += 1; { indir(pointer(const(get1(pc0+1))), short) = sp[-1].i; }
               NEXT;

          ACTION(STGS_L)
               pc = pc0 + 3;
               sp += 1; { indir(pointer(const(get2(pc0+1))), short) = sp[-1].i; }
               NEXT;

          ACTION(STGC_K)
               pc = pc0 + 2;
               sp += 1; { indir(pointer(const(get1(pc0+1))), uchar) = sp[-1].i; }
               NEXT;

          ACTION(STGC_L)
               pc = pc0 + 3;
               sp += 1; { indir(pointer(const(get2(pc0+1))), uchar) = sp[-1].i; }
               NEXT;

          ACTION(STGF_K)
               pc = pc0 + 2;
               sp += 1; { indir(pointer(const(get1(pc0+1))), float) = sp[-1].f; }
               NEXT;

          ACTION(STGF_L)
               pc = pc0 + 3;
               sp += 1; { indir(pointer(const(get2(pc0+1))), float) = sp[-1].f; }
               NEXT;

          ACTION(LDNW_x1)
          ALSO(LDNW_x1+1)
          ALSO(LDNW_x1+2)
          ALSO(LDNW_x1+3)
          ALSO(LDNW_x1+4)
          ALSO(LDNW_x1+5)
          ALSO(LDNW_x1+6)
          ALSO(LDNW_x1+7)
          ALSO(LDNW_x1+8)
          ALSO(LDNW_x1+9)
          ALSO(LDNW_x1+10)
          ALSO(LDNW_x1+11)
          ALSO(LDNW_x1+12)
          ALSO(LDNW_x1+13)
          ALSO(LDNW_x1+14)
               pc = pc0 + 1;
               sp[0].i = indir(pointer(sp[0]) + ir*4-356, int);
               NEXT;

          ACTION(LDNW_1)
               pc = pc0 + 2;
               sp[0].i = indir(pointer(sp[0]) + get1(pc0+1), int);
               NEXT;

          ACTION(LDNW_2)
               pc = pc0 + 3;
               sp[0].i = indir(pointer(sp[0]) + get2(pc0+1), int);
               NEXT;

          ACTION(STNW_x1)
          ALSO(STNW_x1+1)
          ALSO(STNW_x1+2)
          ALSO(STNW_x1+3)
          ALSO(STNW_x1+4)
          ALSO(STNW_x1+5)
          ALSO(STNW_x1+6)
          ALSO(STNW_x1+7)
          ALSO(STNW_x1+8)
          ALSO(STNW_x1+9)
               pc = pc0 + 1;
               sp += 2; { indir(pointer(sp[-2]) + ir*4-424, int) = sp[-1].i; }
               NEXT;

          ACTION(STNW_1)
               pc = pc0 + 2;
               sp += 2; { indir(pointer(sp[-2]) + get1(pc0+1), int) = sp[-1].i; }
               NEXT;

          ACTION(STNW_2)
               pc = pc0 + 3;
               sp += 2; { indir(pointer(sp[-2]) + get2(pc0+1), int) = sp[-1].i; }
               NEXT;

          ACTION(LDIW)
               pc = pc0 + 1;
               sp++; sp[0].i = subs(pointer(sp[0]), sp[-1].i, int);
               NEXT;

          ACTION(LDIF)
               pc = pc0 + 1;
               sp++; sp[0].f = subs(pointer(sp[0]), sp[-1].i, float);
               NEXT;

          ACTION(LDIS)
               pc = pc0 + 1;
               sp++; sp[0].i = subs(pointer(sp[0]), sp[-1].i, short);
               NEXT;

          ACTION(LDIC)
               pc = pc0 + 1;
               sp++; sp[0].i = subs(pointer(sp[0]), sp[-1].i, uchar);
               NEXT;

          ACTION(STIW)
               pc = pc0 + 1;
               sp += 3; { subs(pointer(sp[-2]), sp[-3].i, int) = sp[-1].i; }
               NEXT;

          ACTION(STIF)
               pc = pc0 + 1;
               sp += 3; { subs(pointer(sp[-2]), sp[-3].i, float) = sp[-1].f; }
               NEXT;

          ACTION(STIS)
               pc = pc0 + 1;
               sp += 3; { subs(pointer(sp[-2]), sp[-3].i, short) = sp[-1].i; }
               NEXT;

          ACTION(STIC)
               pc = pc0 + 1;
               sp += 3; { subs(pointer(sp[-2]), sp[-3].i, uchar) = sp[-1].i; }
               NEXT;

          ACTION(LDID)
               pc = pc0 + 1;
               putdbl(&sp[0], getdbl((value *) &subs(pointer(sp[1]), sp[0].i, double)));
               NEXT;

          ACTION(STID)
               pc = pc0 + 1;
               sp += 4; { putdbl((value *) &subs(pointer(sp[-3]), sp[-4].i, double), getdbl(&sp[-2])); }
               NEXT;

          ACTION(LDIQ)
               pc = pc0 + 1;
               putlong(&sp[0], getlong((value *) &subs(pointer(sp[1]), sp[0].i, longint)));
               NEXT;

          ACTION(STIQ)
               pc = pc0 + 1;
               sp += 4; { putlong((value *) &subs(pointer(sp[-3]), sp[-4].i, longint), getlong(&sp[-2])); }
               NEXT;

          ACTION(LOADD)
               pc = pc0 + 1;
               sp--; putdbl(&sp[0], getdbl(valptr(sp[1])));
               NEXT;

          ACTION(STORED)
               pc = pc0 + 1;
               sp += 3; { putdbl(valptr(sp[-3]), getdbl(&sp[-2])); }
               NEXT;

          ACTION(LDKD_1)
               pc = pc0 + 2;
               sp -= 2; putdbl(&sp[0], getdbl(&const(get1(pc0+1))));
               NEXT;

          ACTION(LDKD_2)
               pc = pc0 + 3;
               sp -= 2; putdbl(&sp[0], getdbl(&const(get2(pc0+1))));
               NEXT;

          ACTION(LOADQ)
               pc = pc0 + 1;
               sp--; putlong(&sp[0], getlong(valptr(sp[1])));
               NEXT;

          ACTION(STOREQ)
               pc = pc0 + 1;
               sp += 3; { putlong(valptr(sp[-3]), getlong(&sp[-2])); }
               NEXT;

          ACTION(LDKQ_1)
               pc = pc0 + 2;
               sp -= 2; putlong(&sp[0], getlong(&const(get1(pc0+1))));
               NEXT;

          ACTION(LDKQ_2)
               pc = pc0 + 3;
               sp -= 2; putlong(&sp[0], getlong(&const(get2(pc0+1))));
               NEXT;

          ACTION(INCL_1)
               pc = pc0 + 2;
               { indir(local(get1(pc0+1)), int)++; }
               NEXT;

          ACTION(DECL_1)
               pc = pc0 + 2;
               { indir(local(get1(pc0+1)), int)--; }
               NEXT;

          ACTION(DUP)
          ALSO(DUP+1)
          ALSO(DUP+2)
               pc = pc0 + 1;
               { dup(ir-136, sp); }
               NEXT;

          ACTION(SWAP)
               pc = pc0 + 1;
               { swap(sp); }
               NEXT;

          ACTION(POP_1)
               pc = pc0 + 2;
               { sp += get1(pc0+1); }
               NEXT;

          ACTION(PLUS)
               pc = pc0 + 1;
               sp++; sp[0].i = sp[0].i + sp[-1].i;
               NEXT;

          ACTION(MINUS)
               pc = pc0 + 1;
               sp++; sp[0].i = sp[0].i - sp[-1].i;
               NEXT;

          ACTION(TIMES)
               pc = pc0 + 1;
               sp++; sp[0].i = sp[0].i * sp[-1].i;
               NEXT;

          ACTION(UMINUS)
               pc = pc0 + 1;
               sp[0].i = - sp[0].i;
               NEXT;

          ACTION(AND)
               pc = pc0 + 1;
               sp++; sp[0].i = sp[0].i && sp[-1].i;
               NEXT;

          ACTION(OR)
               pc = pc0 + 1;
               sp++; sp[0].i = sp[0].i || sp[-1].i;
               NEXT;

          ACTION(NOT)
               pc = pc0 + 1;
               sp[0].i = ! sp[0].i;
               NEXT;

          ACTION(INC)
               pc = pc0 + 1;
               sp[0].i = sp[0].i + 1;
               NEXT;

          ACTION(DEC)
               pc = pc0 + 1;
               sp[0].i = sp[0].i - 1;
               NEXT;

          ACTION(BITAND)
               pc = pc0 + 1;
               sp++; sp[0].i = sp[0].i & sp[-1].i;
               NEXT;

          ACTION(BITOR)
               pc = pc0 + 1;
               sp++; sp[0].i = sp[0].i | sp[-1].i;
               NEXT;

          ACTION(BITXOR)
               pc = pc0 + 1;
               sp++; sp[0].i = sp[0].i ^ sp[-1].i;
               NEXT;

          ACTION(BITNOT)
               pc = pc0 + 1;
               sp[0].i = ~ sp[0].i;
               NEXT;

          ACTION(LSL)
               pc = pc0 + 1;
               sp++; sp[0].i = sp[0].i << sp[-1].i;
               NEXT;

          ACTION(LSR)
               pc = pc0 + 1;
               sp++; sp[0].i = ((unsigned) sp[0].i) >> sp[-1].i;
               NEXT;

          ACTION(ASR)
               pc = pc0 + 1;
               sp++; sp[0].i = sp[0].i >> sp[-1].i;
               NEXT;

          ACTION(ROR)
               pc = pc0 + 1;
               sp++; sp[0].i = ror(sp[0].i, sp[-1].i);
               NEXT;

          ACTION(DIV)
               pc = pc0 + 1;
               sp++; sp[0].i = int_divop(sp[0].i, sp[-1].i, 1);
               NEXT;

          ACTION(MOD)
               pc = pc0 + 1;
               sp++; sp[0].i = int_divop(sp[0].i, sp[-1].i, 0);
               NEXT;

          ACTION(EQ)
               pc = pc0 + 1;
               sp++; sp[0].i = sp[0].i == sp[-1].i;
               NEXT;

          ACTION(LT)
               pc = pc0 + 1;
               sp++; sp[0].i = sp[0].i < sp[-1].i;
               NEXT;

          ACTION(GT)
               pc = pc0 + 1;
               sp++; sp[0].i = sp[0].i > sp[-1].i;
               NEXT;

          ACTION(LEQ)
               pc = pc0 + 1;
               sp++; sp[0].i = sp[0].i <= sp[-1].i;
               NEXT;

          ACTION(GEQ)
               pc = pc0 + 1;
               sp++; sp[0].i = sp[0].i >= sp[-1].i;
               NEXT;

          ACTION(NEQ)
               pc = pc0 + 1;
               sp++; sp[0].i = sp[0].i != sp[-1].i;
               NEXT;

          ACTION(JEQ_S)
               pc = pc0 + 2;
               sp += 2; { if (sp[-1].i == sp[-2].i) jump(get1(pc0+1)); }
               NEXT;

          ACTION(JEQ_R)
               pc = pc0 + 3;
               sp += 2; { if (sp[-1].i == sp[-2].i) jump(get2(pc0+1)); }
               NEXT;

          ACTION(JLT_S)
               pc = pc0 + 2;
               sp += 2; { if (sp[-1].i < sp[-2].i) jump(get1(pc0+1)); }
               NEXT;

          ACTION(JLT_R)
               pc = pc0 + 3;
               sp += 2; { if (sp[-1].i < sp[-2].i) jump(get2(pc0+1)); }
               NEXT;

          ACTION(JGT_S)
               pc = pc0 + 2;
               sp += 2; { if (sp[-1].i > sp[-2].i) jump(get1(pc0+1)); }
               NEXT;

          ACTION(JGT_R)
               pc = pc0 + 3;
               sp += 2; { if (sp[-1].i > sp[-2].i) jump(get2(pc0+1)); }
               NEXT;

          ACTION(JLEQ_S)
               pc = pc0 + 2;
               sp += 2; { if (sp[-1].i <= sp[-2].i) jump(get1(pc0+1)); }
               NEXT;

          ACTION(JLEQ_R)
               pc = pc0 + 3;
               sp += 2; { if (sp[-1].i <= sp[-2].i) jump(get2(pc0+1)); }
               NEXT;

          ACTION(JGEQ_S)
               pc = pc0 + 2;
               sp += 2; { if (sp[-1].i >= sp[-2].i) jump(get1(pc0+1)); }
               NEXT;

          ACTION(JGEQ_R)
               pc = pc0 + 3;
               sp += 2; { if (sp[-1].i >= sp[-2].i) jump(get2(pc0+1)); }
               NEXT;

          ACTION(JNEQ_S)
               pc = pc0 + 2;
               sp += 2; { if (sp[-1].i != sp[-2].i) jump(get1(pc0+1)); }
               NEXT;

          ACTION(JNEQ_R)
               pc = pc0 + 3;
               sp += 2; { if (sp[-1].i != sp[-2].i) jump(get2(pc0+1)); }
               NEXT;

          ACTION(JLTZ_S)
               pc = pc0 + 2;
               sp += 1; { if (sp[-1].i < 0) jump(get1(pc0+1)); }
               NEXT;

          ACTION(JGTZ_S)
               pc = pc0 + 2;
               sp += 1; { if (sp[-1].i > 0) jump(get1(pc0+1)); }
               NEXT;

          ACTION(JLEQZ_S)
               pc = pc0 + 2;
               sp += 1; { if (sp[-1].i <= 0) jump(get1(pc0+1)); }
               NEXT;

          ACTION(JGEQZ_S)
               pc = pc0 + 2;
               sp += 1; { if (sp[-1].i >= 0) jump(get1(pc0+1)); }
               NEXT;

          ACTION(JNEQZ_S)
               pc = pc0 + 2;
               sp += 1; { if (sp[-1].i != 0) jump(get1(pc0+1)); }
               NEXT;

          ACTION(JNEQZ_R)
               pc = pc0 + 3;
               sp += 1; { if (sp[-1].i != 0) jump(get2(pc0+1)); }
               NEXT;

          ACTION(JEQZ_S)
               pc = pc0 + 2;
               sp += 1; { if (sp[-1].i == 0) jump(get1(pc0+1)); }
               NEXT;

          ACTION(JEQZ_R)
               pc = pc0 + 3;
               sp += 1; { if (sp[-1].i == 0) jump(get2(pc0+1)); }
               NEXT;

          ACTION(JUMP_S)
               pc = pc0 + 2;
               { jump(get1(pc0+1)); }
               NEXT;

          ACTION(JUMP_R)
               pc = pc0 + 3;
               { jump(get2(pc0+1)); }
               NEXT;

          ACTION(QPLUS)
               pc = pc0 + 1;
               sp += 2; putlong(&sp[0], getlong(&sp[0]) + getlong(&sp[-2]));
               NEXT;

          ACTION(QMINUS)
               pc = pc0 + 1;
               sp += 2; putlong(&sp[0], getlong(&sp[0]) - getlong(&sp[-2]));
               NEXT;

          ACTION(QTIMES)
               pc = pc0 + 1;
               sp += 2; putlong(&sp[0], getlong(&sp[0]) * getlong(&sp[-2]));
               NEXT;

          ACTION(QUMINUS)
               pc = pc0 + 1;
               putlong(&sp[0], - getlong(&sp[0]));
               NEXT;

          ACTION(QDIV)
               pc = pc0 + 1;
               sp += 2; putlong(&sp[0], longint_divop(getlong(&sp[0]), getlong(&sp[-2]), 1));
               NEXT;

          ACTION(QMOD)
               pc = pc0 + 1;
               sp += 2; putlong(&sp[0], longint_divop(getlong(&sp[0]), getlong(&sp[-2]), 0));
               NEXT;

          ACTION(JCASE_1)
               pc = pc0 + 2;
               sp += 1; { jcase(sp[-1].i, get1(pc0+1)); }
               NEXT;

          ACTION(JRANGE_S)
               pc = pc0 + 2;
               sp += 3; { if (sp[-1].i >= sp[-2].i && sp[-1].i <= sp[-3].i) jump(get1(pc0+1)); }
               NEXT;

          ACTION(JRANGE_R)
               pc = pc0 + 3;
               sp += 3; { if (sp[-1].i >= sp[-2].i && sp[-1].i <= sp[-3].i) jump(get2(pc0+1)); }
               NEXT;

          ACTION(TESTGEQ_S)
               pc = pc0 + 2;
               sp++; { if (sp[0].i >= sp[-1].i) jump(get1(pc0+1)); }
               NEXT;

          ACTION(TESTGEQ_R)
               pc = pc0 + 3;
               sp++; { if (sp[0].i >= sp[-1].i) jump(get2(pc0+1)); }
               NEXT;

          ACTION(FPLUS)
               pc = pc0 + 1;
               sp++; sp[0].f = sp[0].f + sp[-1].f;
               NEXT;

          ACTION(FMINUS)
               pc = pc0 + 1;
               sp++; sp[0].f = sp[0].f - sp[-1].f;
               NEXT;

          ACTION(FTIMES)
               pc = pc0 + 1;
               sp++; sp[0].f = sp[0].f * sp[-1].f;
               NEXT;

          ACTION(FDIV)
               pc = pc0 + 1;
               sp++; sp[0].f = sp[0].f / sp[-1].f;
               NEXT;

          ACTION(FUMINUS)
               pc = pc0 + 1;
               sp[0].f = - sp[0].f;
               NEXT;

          ACTION(FCMPL)
               pc = pc0 + 1;
               sp++; sp[0].i = fcmpl(sp[0].f, sp[-1].f);
               NEXT;

          ACTION(FCMPG)
               pc = pc0 + 1;
               sp++; sp[0].i = fcmpg(sp[0].f, sp[-1].f);
               NEXT;

          ACTION(DPLUS)
               pc = pc0 + 1;
               sp += 2; putdbl(&sp[0], getdbl(&sp[0]) + getdbl(&sp[-2]));
               NEXT;

          ACTION(DMINUS)
               pc = pc0 + 1;
               sp += 2; putdbl(&sp[0], getdbl(&sp[0]) - getdbl(&sp[-2]));
               NEXT;

          ACTION(DTIMES)
               pc = pc0 + 1;
               sp += 2; putdbl(&sp[0], getdbl(&sp[0]) * getdbl(&sp[-2]));
               NEXT;

          ACTION(DDIV)
               pc = pc0 + 1;
               sp += 2; putdbl(&sp[0], getdbl(&sp[0]) / getdbl(&sp[-2]));
               NEXT;

          ACTION(DUMINUS)
               pc = pc0 + 1;
               putdbl(&sp[0], - getdbl(&sp[0]));
               NEXT;

          ACTION(DCMPL)
               pc = pc0 + 1;
               sp += 3; sp[0].i = fcmpl(getdbl(&sp[-1]), getdbl(&sp[-3]));
               NEXT;

          ACTION(DCMPG)
               pc = pc0 + 1;
               sp += 3; sp[0].i = fcmpg(getdbl(&sp[-1]), getdbl(&sp[-3]));
               NEXT;

          ACTION(QCMP)
               pc = pc0 + 1;
               sp += 3; sp[0].i = lcmp(getlong(&sp[-1]), getlong(&sp[-3]));
               NEXT;

          ACTION(CONVNF)
               pc = pc0 + 1;
               sp[0].f = flo_conv(sp[0].i);
               NEXT;

          ACTION(CONVND)
               pc = pc0 + 1;
               sp--; putdbl(&sp[0], flo_conv(sp[1].i));
               NEXT;

          ACTION(CONVFN)
               pc = pc0 + 1;
               sp[0].i = (int) sp[0].f;
               NEXT;

          ACTION(CONVDN)
               pc = pc0 + 1;
               sp++; sp[0].i = (int) getdbl(&sp[-1]);
               NEXT;

          ACTION(CONVFD)
               pc = pc0 + 1;
               sp--; putdbl(&sp[0], sp[1].f);
               NEXT;

          ACTION(CONVDF)
               pc = pc0 + 1;
               sp++; sp[0].f = (float) getdbl(&sp[-1]);
               NEXT;

          ACTION(CONVNC)
               pc = pc0 + 1;
               sp[0].i = sp[0].i & 0xff;
               NEXT;

          ACTION(CONVNS)
               pc = pc0 + 1;
               sp[0].i = (short) sp[0].i;
               NEXT;

          ACTION(CONVNQ)
               pc = pc0 + 1;
               sp--; putlong(&sp[0], sp[1].i);
               NEXT;

          ACTION(CONVQN)
               pc = pc0 + 1;
               sp++; sp[0].i = (int) getlong(&sp[-1]);
               NEXT;

          ACTION(CONVQD)
               pc = pc0 + 1;
               putdbl(&sp[0], flo_convq(getlong(&sp[0])));
               NEXT;

          ACTION(BOUND_2)
               pc = pc0 + 3;
               sp++; sp[0].i = czech2(boundcheck, sp[0].i, sp[-1].i, get2(pc0+1));
               NEXT;

          ACTION(NCHECK_2)
               pc = pc0 + 3;
               sp[0].a = address(czech(nullcheck, pointer(sp[0]), get2(pc0+1)));
               NEXT;

          ACTION(GCHECK_2)
               pc = pc0 + 3;
               sp += 1; { czech(globcheck, valptr(sp[-1]), get2(pc0+1)); }
               NEXT;

          ACTION(ZCHECK_2)
               pc = pc0 + 3;
               sp[0].i = czech(zerocheck, sp[0].i, get2(pc0+1));
               NEXT;

          ACTION(FZCHECK_2)
               pc = pc0 + 3;
               sp[0].f = czech(fzerocheck, sp[0].f, get2(pc0+1));
               NEXT;

          ACTION(DZCHECK_2)
               pc = pc0 + 3;
               putdbl(&sp[0], czech(fzerocheck, getdbl(&sp[0]), get2(pc0+1)));
               NEXT;

          ACTION(QZCHECK_2)
               pc = pc0 + 3;
               putlong(&sp[0], czech(lzerocheck, getlong(&sp[0]), get2(pc0+1)));
               NEXT;

          ACTION(ERROR_12)
               pc = pc0 + 4;
               { error(get1(pc0+1), get2(pc0+2)); }
               NEXT;

          ACTION(ALIGNC)
               pc = pc0 + 1;
               sp[0].i = alignx(sp[0].i, 8);
               NEXT;

          ACTION(ALIGNS)
               pc = pc0 + 1;
               sp[0].i = alignx(sp[0].i, 16);
               NEXT;

          ACTION(FIXCOPY)
               pc = pc0 + 1;
               sp += 3; { fixcopy(pointer(sp[-1]), pointer(sp[-2]), sp[-3].i); }
               NEXT;

          ACTION(FLEXCOPY)
               pc = pc0 + 1;
               sp += 2; { flexcopy(pointer(sp[-1]), sp[-2].i); }
               NEXT;

          ACTION(LINK)
               pc = pc0 + 1;
               sp += 1; { statlink = valptr(sp[-1]); }
               NEXT;

          ACTION(SAVELINK)
               pc = pc0 + 1;
               { bp[SL].a = address(statlink); }
               NEXT;

          ACTION(JPROC)
               pc = pc0 + 1;
               { 
     value *p = valptr(sp[0]);
     sp -= HEAD-1; sp[BP].a = address(bp); sp[PC].a = address(pc);
     if (! interpreted(p)) {
#ifdef PROFILE
          /* Calling a native-code routine */
          prof_enter(p, ticks, PROF_PRIM);
          ticks = 0;
#endif
#ifdef OBXDEB
          prim_bp = sp;
#endif
          primcall(p, sp);
#ifdef OBXDEB
          prim_bp = NULL;
#endif
     } else {
#ifdef PROFILE
          prof_enter(p, ticks, PROF_CALL);
#endif
          cp = p; pc = pointer(cp[CP_CODE]);
          do_find_proc;
          frame();
     }
 }
               NEXT;

          ACTION(SLIDE_1)
               pc = pc0 + 2;
               { slide(get1(pc0+1)); }
               NEXT;

          ACTION(SLIDEW_1)
               pc = pc0 + 2;
               { slide(get1(pc0+1)); sp--; sp[0].i = ob_res.i; }
               NEXT;

          ACTION(SLIDED_1)
               pc = pc0 + 2;
               { slide(get1(pc0+1)); sp -= 2; 
                                putdbl(&sp[0], getdbl(&ob_res)); }
               NEXT;

          ACTION(SLIDEF_1)
               pc = pc0 + 2;
               { slide(get1(pc0+1)); sp--; sp[0].f = ob_res.f; }
               NEXT;

          ACTION(SLIDEQ_1)
               pc = pc0 + 2;
               { slide(get1(pc0+1)); sp -= 2;
                                putlong(&sp[0], getlong(&ob_res)); }
               NEXT;

          ACTION(RESULTW)
               pc = pc0 + 1;
               sp += 1; { ob_res = sp[-1]; }
               NEXT;

          ACTION(RESULTD)
               pc = pc0 + 1;
               sp += 2; { putdbl(&ob_res, getdbl(&sp[-2])); }
               NEXT;

          ACTION(RESULTF)
               pc = pc0 + 1;
               sp += 1; { ob_res.f = sp[-1].f; }
               NEXT;

          ACTION(RESULTQ)
               pc = pc0 + 1;
               sp += 2; { putlong(&ob_res, getlong(&sp[-2])); }
               NEXT;

          ACTION(RETURN)
               pc = pc0 + 1;
               { 
     if (bp == base) {
          level--;
#ifdef PROFILE
          prof_exit(NULL, ticks);
#endif
          return;
     }

     sp = bp; pc = pointer(sp[PC]); bp = valptr(sp[BP]); cp = valptr(bp[CP]);
     do_find_proc;
#ifdef PROFILE
     prof_exit(cp, ticks);
     ticks = 0;
#endif
     cond_break();
 }
               NEXT;

          ACTION(LNUM_2)
               pc = pc0 + 3;
               { 
#ifdef PROFILE
     if (lflag) { 
          static module m = NULL; /* Cache most recent module */
          ticks--;
          if (m == NULL || cp < (value *) m->m_addr 
                || cp >= (value *) (m->m_addr + m->m_length)) {
               m = find_module(cp);
          }
          m->m_lcount[get2(pc0+1)-1]++; 
     }
#endif
#ifdef OBXDEB
     if (intflag)
          debug_break(cp, bp, pc0, "interrupt");
     else if (one_shot) 
          debug_break(cp, bp, pc0, "line");
#endif
 }
               NEXT;

          ACTION(BREAK_2)
               pc = pc0 + 3;
               { 
#ifdef OBXDEB
     debug_break(cp, bp, pc0, "break");
#endif
 }
               NEXT;

          ACTION(CASEJUMP_1)
               pc = pc0 + 2;
               sp += 1; { casejump(sp[-1].i, get1(pc0+1)); }
               NEXT;

          ACTION(PACK)
               pc = pc0 + 1;
               sp++; sp[0].i = pack(valptr(sp[-1]), pointer(sp[0]));
               NEXT;

          ACTION(UNPACK)
               pc = pc0 + 1;
               { sp--; sp[0].a = address(getcode(sp[1].i)); 
                                   sp[1].a = address(getenvt(sp[1].i)); }
               NEXT;


          ACTION(ILLEGAL)
          DEFAULT
               panic("*illegal instruction %d", ir);
#ifndef JTABLE
          }
     }
#endif
}
