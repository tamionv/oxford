
\documentclass[a4paper,9pt]{article}
\usepackage{hyperref}
\usepackage{hhline}
\usepackage[T1]{fontenc} 
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{tabularx}
\usepackage[margin=0.5in]{geometry}
\usepackage{multicol}


\usepackage{amsmath,amssymb,amsthm} 
\setlength\parindent{0pt}
\renewcommand{\familydefault}{\sfdefault}

\title{Compilers assignment report}
\author{Tamio-Vesa Nakajima}
\date{\today}

\lstdefinestyle{tvnstyle}{
    backgroundcolor=\color{white},   
    commentstyle=\color{lightgray},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{blue},
    stringstyle=\color{red},
    basicstyle=\ttfamily\scriptsize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=none,
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}
\lstdefinestyle{teststyle}{
    backgroundcolor=\color{white},   
    commentstyle=\color{black},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{blue},
    stringstyle=\color{red},
    basicstyle=\ttfamily\scriptsize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=none,
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    morecomment=[f][\color{lightgray}]@
}

\newcommand{\lstbg}[3][0pt]{{\fboxsep#1\colorbox{#2}{\strut #3}}}
\lstdefinelanguage{diff}{
     morecomment=[f][\lstbg{red!20}]-,
     morecomment=[f][\lstbg{green!20}]+,
     morecomment=[f][\textit]{diff},
     morecomment=[f][\textit]{---},
     morecomment=[f][\textit]{+++},
     morecomment=[f][\lstbg{darkgray!20}]{diff},
     morecomment=[f][\lstbg{darkgray!20}]{+++},
     morecomment=[f][\lstbg{darkgray!20}]{---},
     morecomment=[f][\textit]{@@},
}


\begin{document}

\lstset{style=tvnstyle}

\maketitle

\section{Task}
The task requires us to add \texttt{continue} statements and call-by-name semantics to the compiler given in lab 4. This report contains both a description of the changes made, as well as the tests added to test these features. Also, Appendix A shows fully the changes made, and Appendix B contains the full text of the tests, including the output the test should generate when run, and the output generated by the compiler for these tests.

\section{Continue statements}
Adding \texttt{continue} statements to the language requires modifying several aspects of the compiler: the lexer, the abstract syntax tree, the parser, the semantic analyser, the tree generator and the code generator. The changes to these aspects, together with testing, are described below.

\subsection{Lexical analysis}
To modify the lexer for our purposes, add a corresponding symbol to \texttt{symtable}, as follows:

\lstinputlisting[language=ml, firstline=14, lastline=
\begin{lstlisting}[language=ml]
let symtable = 
  Util.make_hash 100
    [ ("continue", CONTINUE); (* all old symbols *) ]
\end{lstlisting}

\subsection{Abstract syntax}
To modify the abstract syntax for our purposes, add a new constructor \texttt{ContinueStmt} to the type \texttt{stmt\_guts}, as follows:

\begin{lstlisting}[language=ml]
and stmt_guts =
  (* all the old constructors *)
  | ContinueStmt ;
\end{lstlisting}

\subsection{Parsing}

To modify the parser to accept continue statements, add a new token \texttt{CONTINUE}, as follows:

\begin{lstlisting}[language=c]
%token                  CONTINUE
\end{lstlisting}

Also, add a new rule for \texttt{stmt1} that produces a \texttt{ContinueStmt}, as follows:

\begin{lstlisting}[language=c]
stmt1 :
  /* all the old rules */
  | CONTINUE                            { ContinueStmt } ;
\end{lstlisting}

\subsection{Semantic analysis}
Several modifications must be made to the semantic analyser:
\begin{itemize}
    \item Add a reference to a boolean called \texttt{in\_loop}, in the scope of check\_stmt, that contains \texttt{true} if and only if the statement we are currently checking is inside a loop:
\begin{lstlisting}[language=ml]
let rec in_loop = ref false
and check_stmt s env alloc = (*...*)
\end{lstlisting}

\item For \texttt{while}, \texttt{repeat} and \texttt{for} statements, add code that modifies \texttt{in\_loop} before and after the pre-existing code, in order to preserve the property that characterises \texttt{in\_loop}:
\begin{lstlisting}[language=ml]
and check_stmt s env alloc =
  err_line := s.s_line;
  match s.s_guts with
    (* Other cases, such as Skip, Seq ss, etc. *)
    | (*While/Repeat/For*)Stmt (*Parameters*) ->
        let old_in_loop_value = !in_loop in
        in_loop := true;
        (* Old code *)
        in_loop := old_in_loop_value
\end{lstlisting}
\item For \texttt{continue} statements, if \texttt{in\_loop} contains \texttt{false}, raise an appropriate semantic error:
\begin{lstlisting}[language=ml]
and check_stmt s env alloc =
  err_line := s.s_line;
  match s.s_guts with
    (* Other cases *)
     | ContinueStmt ->
        if not !in_loop
        then sem_error "continue expression must be in a loop" []
        else ()
\end{lstlisting}
\end{itemize}

\subsection{Translation}
Several changes must be made to the procedure \texttt{gen\_stmt}, in \texttt{tran.ml}:
\begin{itemize}
    \item First, we add \texttt{continue\_lab}, a reference to the label to which a \texttt{continue} statement should jump, in the scope of \texttt{gen\_stmt}:
\begin{lstlisting}[language=ml]
let rec continue_lab = ref (label ())
and gen_stmt s = 
\end{lstlisting}
    \item \texttt{while} statements must remember the previous value for \texttt{continue\_lab}, reassign it appropriately, generate code for the \texttt{while} statement (storing the result in \texttt{return\_value}), restore the old value of \texttt{continue\_lab}, then return the stored code:
\begin{lstlisting}[language=ml]
and gen_stmt s = 
    (* Other cases *)
      | WhileStmt (test, body) ->
          (* The test is at the top, improving the chances of finding
             common subexpressions between the test and loop body. *)
          let l1 = label () and l2 = label () and l3 = label()
          and old_continue_lab = !continue_lab in
          continue_lab := l1;
          let return_value = 
              <SEQ,
                <LABEL l1>,
                gen_cond test l2 l3,
                <LABEL l2>,
                gen_stmt body,
                <JUMP l1>,
                <LABEL l3>> in
          continue_lab := old_continue_lab;
          return_value
\end{lstlisting}
    \item I first add an extra label in the code generated for \texttt{repeat} statements, immediately before the code that tests the loop condition; this is jumped to by \texttt{continue} statements in this loop. I then modify \texttt{continue\_lab} before and after code generation as with \texttt{while} statements:
\begin{lstlisting}[language=ml]
and gen_stmt s = 
    (* Other cases *)
      | RepeatStmt (body, test) ->
          let l1 = label () and l2 = label () and l3 = label ()
          and old_continue_lab = !continue_lab in
          continue_lab := l2;
          let return_value = 
              <SEQ,
                <LABEL l1>,
                gen_stmt body, 
                <LABEL l2>,
                gen_cond test l3 l1,
                <LABEL l3>> in
          continue_lab := old_continue_lab;
          return_value
\end{lstlisting}
    \item \texttt{for} statements are modified very similarly to \texttt{repeat} statements:
\begin{lstlisting}[language=ml]
and gen_stmt s = 
    (* Other cases *)
      | ForStmt (var, lo, hi, body, upb) ->
          (* Use previously allocated temp variable to store upper bound.
             We could avoid this if the upper bound is constant. *)
          let tmp = match !upb with Some d -> d | _ -> failwith "for" in
          let l1 = label () and l2 = label () and l3 = label ()
          and old_continue_lab = !continue_lab in
          continue_lab := l2;
          let return_value =
              <SEQ,
                <STOREW, gen_expr lo, gen_addr var>,
                <STOREW, gen_expr hi, address tmp>,
                <LABEL l1>,
                <JUMPC (Gt, l3), gen_expr var, <LOADW, address tmp>>,
                gen_stmt body,
                <LABEL l2>,
                <STOREW,
                    <BINOP Plus, gen_expr var, <CONST 1>>, gen_addr var>,
                <JUMP l1>,
                <LABEL l3>> in
          continue_lab := old_continue_lab;
          return_value
\end{lstlisting}
    \item \texttt{continue} statements are translated directly into \texttt{JUMP}'s to \texttt{!continue\_lab}:
\begin{lstlisting}[language=ml]
and gen_stmt s = 
    (* Other cases *)
      | ContinueStmt -> <JUMP !continue_lab>
\end{lstlisting}
\end{itemize}
\subsection{Code generation}
The pre-existing code generator is sufficient to generate correct code, and the code it generates is reasonably clean; the examples I created reveal no obvious inefficiencies, and most of the old examples now generate the same code, ignoring differences in label names, on optimisation level \texttt{-O2}.
\subsection{Testing}
All previous tests continue to pass; additionally, I have added 6 new tests (which pass): \\
\begin{tabularx}{\linewidth}{ |X|X| }
\hline
    \textbf{Test name} & \textbf{Test function} \\
\hhline{|=|=|}
    \texttt{while\_continue.p} & Tests a \texttt{continue} statement inside a \texttt{while} loop. \\
\hline
    \texttt{repeat\_continue.p} & Tests a \texttt{continue} statement inside a \texttt{repeat} loop. \\
\hline
    \texttt{for\_continue.p} & Tests a \texttt{continue} statement inside a \texttt{for} loop. \\
\hline
    \texttt{bare\_continue.p} & Tests a \texttt{continue} statement not inside a loop \footnote{NB: this should produce an error -- to be able to test this, I have extended the testing script in the \texttt{Makefile} so that error messages can be tested}. \\
\hline
    \texttt{multiple\_continues.p} & Tests loops that contain multiple \texttt{continue} statements. \\
\hline
    \texttt{nested\_continue.p} & Tests continue statements inside nested loops \\
\hline
\end{tabularx}

\section{Call-by-name semantics}
First, a preliminary note; notice the peculiarities of the following code:
\begin{lstlisting}[language=pascal]
proc f(=> x : integer);
begin
    print_num(x);
    print_num(x);
    newline()
end;
proc g(var x : integer);
begin
    x := x + 1;
    return x
end;
proc h();
    var x : integer;
begin
    f(g(x) + 3)
end;
begin
    h()
end.
\end{lstlisting}

Interestingly, \texttt{f} has no natural way of accessing the variable \texttt{x}, so it must be passed this variables address (the value is not sufficient, because \texttt{g} changes the value of \texttt{x}). For simplicity though, rather than exhaustively passing the address of each variable mentioned in an expression "by hand", which might take very much stack space, it makes more sense to simply wrap each by-name parameter in an anonymous closure, and pass this (i.e. pass a thunk). In this method, the code in the example should compile to the same code as:

\begin{lstlisting}[language=pascal]
proc f(proc x(__x: integer): integer): integer;
begin
    print_num(x());
    print_num(x());
    newline()
end;
proc g(var x : integer): integer;
begin
    x := x + 1;
    return x
end;
proc h(): integer;
    var x : integer;
    proc anonymous();
    begin
        return g(x) + 3;
    end;
begin
    f(anonymous)
end;
begin
    h()
end.
\end{lstlisting}
In essence, a function that accepts a by-name parameter will treat that parameter precisely as though it were a function that takes no arguments and returns an \texttt{integer}; and code calling a function with such parameters will wrap the expression passed in an anonymous function. This implementation will also not allow getting the address of a call-by-name parameter (i.e. not letting such parameters be assigned to, or letting them be passed by-reference). This is in accordance with the specification (since it only mentions call-by-name parameters being "evaluated" as values, not as references), and does not reduce functionality (as demonstrated by the test cases that implement Jensen's device and Knuth and Merner's general problem solver), since our language includes call-by-reference parameters. \\
I split the implementation of this feature into the same parts as before.

\subsection{Lexical analysis}
To modify the lexer for our purposes, add a new rule to \texttt{rule token}:
\begin{lstlisting}[language=ml]
rule token =
    (* Other rules *)
    | "=>"              { RIGHTARROW }
\end{lstlisting}

\subsection{Abstract Syntax}
We must add a new constructor \texttt{NParamDef} to the type \texttt{def\_kind}, defined in \texttt{dict.ml} and \texttt{dict.mli}. Also, I extend \texttt{fKind} to accept parameters constructed by \texttt{NParamDef}.

\subsection{Parsing}

To modify the parser to accept continue statements, first a new token \texttt{RIGHTARROW}, as follows:

\begin{lstlisting}[language=c]
%token                  RIGHTARROW
\end{lstlisting}

and then add a new rule to \texttt{formal\_decl}, as follows:

\begin{lstlisting}[language=c]
formal_decl :   
    /* Other rules */
   | RIGHTARROW ident_list COLON typexpr { VarDecl (NParamDef, $2, $4) }
\end{lstlisting}

\subsection{Semantic Analysis}
Several changes must be made to the semantic analyser:
\begin{itemize}
    \item I make \texttt{NParamDef} work precisely like \texttt{VarDef} in functions \texttt{has\_value}, \texttt{do\_alloc}.
    \item I modify \texttt{check\_var} to output an appropriate error message for by-name parameters.
    \item I make \texttt{NParamDef} work precisely like \texttt{VParamDef} in function \texttt{check\_arg}.
    \item I make \texttt{NParamDef} work precisely like \texttt{PParamDef} in function \texttt{param\_alloc}.
    \item I add functions \texttt{contains\_call\_by\_name} (which checks if a particular declarations contains a call-by-name parameter at any level) and \texttt{check\_param} (which checks that all call-by-name parameters are integers, and that no parameters are functions that take call-by-name parameters), as follows:
\begin{lstlisting}[language=ml]
and contains_call_by_name d = match d with
  VarDecl(NParamDef, _, _) -> true
  | PParamDecl(Heading(_, params, _)) -> List.exists contains_call_by_name params
  | _ -> false

and check_param env d = match d with
  VarDecl(NParamDef, _, te) ->
        let t = check_typexpr te env in
        (
        match t.t_guts with
            BasicType IntType -> ()
            | _ -> sem_error "Call by name parameter must be an integer" []
        )
  | PParamDecl (Heading(_, params, _)) ->
      if List.exists contains_call_by_name params
      then sem_error "Functions that use call-by-name parameters cannot be parameters" []
      else ()
  | _ -> ()
\end{lstlisting}
    \item I also make the function \texttt{check\_heading} check, using \texttt{check\_param}, that all parameters follow these properties.
\end{itemize}
\section{Translation}
Several changes must be made;
\begin{itemize}
    \item I make \texttt{gen\_closure} work on \texttt{NParamDef}'s the same as it does on \texttt{PParamDef}'s.
    \item I make \texttt{gen\_addr} generate an appropriate error (\texttt{Named parameters have no address}) when asked to generate an address for a call by name parameter.
    \item I make \texttt{gen\_expr} treat \texttt{NParamDef}'s like function calls that take no arguments:
\begin{lstlisting}[language=ml]
and gen_expr e =
  match e.e_value with
      Some v -> 
        <CONST v>
    | None -> 
        begin
          match e.e_guts with
              Variable x when (get_def x).d_kind == NParamDef ->
                gen_call x []
        (* other cases *)
\end{lstlisting}
    \item I make \texttt{gen\_call} treat \texttt{NParamDef}'s exactly like normal procedures, just with no parameters:
\begin{lstlisting}[language=ml]
and gen_call x args =
  let d = get_def x in
  match d.d_kind with
    (* Other cases *)
    | NParamDef ->
        let (fn, sl) = gen_closure d in
        <CALL 0, @(fn :: <STATLINK, sl> :: [])>
    (* Other cases *)
\end{lstlisting}
    \item I add a new counter \texttt{curr\_anonymous} and an associated function \texttt{get\_anonymous\_label}, which generates names for anonymous functions. The names are of the form \texttt{\_\_anonymous\_id}, where \texttt{id} is the current value of \texttt{curr\_anonymous} (which shall be incremented after each call of \texttt{get\_anonymous\_label}); this scheme insures that no two anonymous function names can coincide (due to \texttt{id}), and that an anonymous function's name will never coincide with a user-defined function's name (since user defined functions cannot begin with \texttt{\_}):
\begin{lstlisting}[language=ml]
and curr_anonymous = ref 0
and get_anonymous_label () = 
    curr_anonymous := 1 + !curr_anonymous;
    sprintf "__anonymous_$" [fNum !curr_anonymous]
$
\end{lstlisting}
\item I add a new global variable, \texttt{anonymous\_functions\_to\_be\_generated}, a reference to an initially empty list. This will hold 3-tuples \texttt{(label, level, block)}, each of which represent that we need to generate a function whose name is \texttt{label}, at level \texttt{level}, whose body is \texttt{block}
\item I make \texttt{gen\_arg} treat \texttt{NParamDef}'s as follows:
    \begin{enumerate}
        \item We extract the expression which is passed as a parameter.
        \item We create a block of code that corresponds to a body of a function that simply returns that expression
        \item We create an anonymous function name, using \texttt{get\_anonymous\_label}.
        \item We push these values onto \texttt{anonymous\_functions\_to\_be\_generated}, to be generated later.
        \item We generate code that pushes a closure for the function we just created onto the stack.
    \end{enumerate}
    The code follows:
\begin{lstlisting}[language=ml]
and gen_arg f a = 
  match f.d_kind with
    | NParamDef ->
            (
            let expr = a.e_guts in
            let block = makeBlock ([],
                {s_guts = Return (Some 
                    { e_guts = expr
                    ; e_type = integer
                    ; e_value = None
                    })
                ; s_line = -1
                }) in
            let lab = get_anonymous_label () in
            anonymous_functions_to_be_generated := 
                (lab, !level, block) :: !anonymous_functions_to_be_generated;
            [<GLOBAL lab>; <LOCAL 0>]
            )
\end{lstlisting}
    \item I make \texttt{gen\_arg} be able to call \texttt{gen\_proc}, by replacing the \texttt{let}'s between the two functions with \texttt{and}'s.
    \item I add a new function \texttt{build\_all\_anonymous} (which is called in \texttt{translate}) that will repeatedly try to build all the functions in \texttt{anonymous\_functions\_to\_be\_generated}. The function is defined as follows since building an anonymous function may necessitate more anonymous functions, which are stored temporarily in \texttt{anonymous\_functions\_to\_be\_generated}:
\begin{lstlisting}[language=ml]
let rec build_all_anonymous () =
    let tmp = List.rev !anonymous_functions_to_be_generated in
    anonymous_functions_to_be_generated := [];
    List.map (fun (lab, lev, bl) -> do_proc lab lev 0 bl) tmp;
    if (List.length !anonymous_functions_to_be_generated > 0)
        then build_all_anonymous ()
        else ()
\end{lstlisting}
\end{itemize}
\subsection{Code generation}
The pre-existing code generator is sufficient to generate correct code, and the code it generates is reasonably clean.
\section{Testing}

All previous tests continue to pass; additionally, I have added several new tests (which pass): \\
\begin{tabularx}{\linewidth}{ |X|X| }
\hline
    \textbf{Test name} & \textbf{Test function} \\
\hhline{|=|=|}
    \texttt{by\_name\_not\_param.p} & Tests that using a function that takes a call by name parameter as a parameter generates an appropriate error. \\
\hline
    \texttt{rightarrow\_non\_int\_error.p} & Tests that using a non-integer call by name parameter leads to an appropriate error. \\
\hline
    \texttt{given\_named\_param\_test.p} & Contains the example given in the task description. \\
\hline
    \texttt{lazy\_evaluate\_by\_name.p} & Tests that by name parameters are not evaluated if they are not used. \\
\hline
    \texttt{reevaluate\_by\_name.p} & Tests that by name parameters are re-evaluated each time they are used. \\
\hline
    \texttt{rightarrow\_same\_as\_var.p} & Tests that call by name parameter declarations are syntactically similar to call by reference parameter declarations (i.e. they can be followed by a list of parameters). \\
\hline
    \texttt{by\_name\_local.p} & Tests that a by name parameter containing a local variable not in the scope of the called function works correctly. \\
\hline
    \texttt{by\_name\_nested\_function.p} & Tests that a by name parameter containing implicit changes to state not known by the called function works correctly. \\
\hline
    \texttt{local\_to\_by\_name.p} & Tests that a local variable can be passed as a by-name parameter to another function. \\
\hline
    \texttt{by\_name\_to\_by\_name.p} & Tests that a by-name parameter can be passed as a by-name parameter to another function. \\
\hline
    \texttt{by\_reference\_to\_by\_name.p} & Tests that a by-reference parameter can be passed as a by-name parameter to another function. \\
\hline
    \texttt{by\_name\_not\_by\_ref.p} & Tests that a by-name parameter cannot be passed as a by-reference parameter to another function. \\
\hline
    \texttt{by\_name\_not\_assigned.p} & Tests that a by-reference parameter cannot be assigned to. \\
\hline
    \texttt{gps\_primes.p} & Tests an application of Knuth and Merner's general problem solver that calculates prime numbers. \\
\hline
    \texttt{jensen1.p} & Tests both a simple application of Jensen's device, and that local variables can be passed as by-name parameters. \\
\hline
    \texttt{jensen2.p} & Tests both a more complicated application of Jensen's device, and that global variables can be passed as by-name parameters. \\
\hline
    \texttt{jensen2d.p} & Tests using Jensen's device to calculate the sum of a matrix, and that locals can be passed by-name. \\
\hline
    \texttt{jensen3.p} & Tests complicated application of Jensen's device, and that global variables can be passed as by-name parameters. \\
\hline
    \texttt{jensen\_function.p} & Calculates $1^4 + ... + 9^4$ using Jensen's device. \\
\hline
\end{tabularx}
\section{Appendix A}
A full, automatically generated (with \texttt{hg diff -r initial\_revision\_number *.ml *.mll *.mly *.mli}), description of the changes made to the compiler:
\lstinputlisting[language=diff]{diffset}
\section{Appendix B}
\lstset{style=teststyle}

The full text of all tests:

\begin{multicols}{2}

\subsection{\textbf{\texttt{bare\_continue.p}}}
\lstinputlisting[language=pascal]{lab4/test/bare_continue.p}

\subsection{\textbf{\texttt{by\_name\_local.p}}}
\lstinputlisting[language=pascal]{lab4/test/by_name_local.p}

\subsection{\textbf{\texttt{by\_name\_nested\_function.p}}}
\lstinputlisting[language=pascal]{lab4/test/by_name_nested_function.p}

\subsection{\textbf{\texttt{by\_name\_not\_param.p}}}
\lstinputlisting[language=pascal]{lab4/test/by_name_not_param.p}

\subsection{\textbf{\texttt{by\_name\_to\_by\_name.p}}}
\lstinputlisting[language=pascal]{lab4/test/by_name_to_by_name.p}

\subsection{\textbf{\texttt{by\_ref\_to\_by\_name.p}}}
\lstinputlisting[language=pascal]{lab4/test/by_ref_to_by_name.p}

\subsection{\textbf{\texttt{for\_continue.p}}}
\lstinputlisting[language=pascal]{lab4/test/for_continue.p}

\subsection{\textbf{\texttt{given\_named\_param\_test.p}}}
\lstinputlisting[language=pascal]{lab4/test/for_continue.p}

\subsection{\textbf{\texttt{gps\_primes.p}}}
\lstinputlisting[language=pascal]{lab4/test/gps_primes.p}

\subsection{\textbf{\texttt{jensen1.p}}}
\lstinputlisting[language=pascal]{lab4/test/jensen1.p}

\subsection{\textbf{\texttt{jensen2.p}}}
\lstinputlisting[language=pascal]{lab4/test/jensen2.p}

\subsection{\textbf{\texttt{jensen2d.p}}}
\lstinputlisting[language=pascal]{lab4/test/jensen2d.p}

\subsection{\textbf{\texttt{jensen3.p}}}
\lstinputlisting[language=pascal]{lab4/test/jensen3.p}

\subsection{\textbf{\texttt{jensen\_function.p}}}
\lstinputlisting[language=pascal]{lab4/test/jensen_function.p}

\subsection{\textbf{\texttt{lazy\_evaluate\_by\_name.p}}}
\lstinputlisting[language=pascal]{lab4/test/lazy_evaluate_by_name.p}

\subsection{\textbf{\texttt{local\_to\_by\_name.p}}}
\lstinputlisting[language=pascal]{lab4/test/local_to_by_name.p}

\subsection{\textbf{\texttt{multiple\_continues.p}}}
\lstinputlisting[language=pascal]{lab4/test/multiple_continues.p}

\subsection{\textbf{\texttt{nested\_continue.p}}}
\lstinputlisting[language=pascal]{lab4/test/nested_continue.p}

\subsection{\textbf{\texttt{reevaluate\_by\_name.p}}}
\lstinputlisting[language=pascal]{lab4/test/reevaluate_by_name.p}

\subsection{\textbf{\texttt{repeat\_continue.p}}}
\lstinputlisting[language=pascal]{lab4/test/repeat_continue.p}

\subsection{\textbf{\texttt{rightarrow\_non\_int\_error.p}}}
\lstinputlisting[language=pascal]{lab4/test/rightarrow_non_int_error.p}

\subsection{\textbf{\texttt{rightarrow\_same\_as\_var.p}}}
\lstinputlisting[language=pascal]{lab4/test/rightarrow_same_as_var.p}

\subsection{\textbf{\texttt{while\_continue.p}}}
\lstinputlisting[language=pascal]{lab4/test/while_continue.p}

\subsection{\textbf{\texttt{by\_name\_not\_by\_ref.p}}}
\lstinputlisting[language=pascal]{lab4/test/by_name_not_by_ref.p}

\subsection{\textbf{\texttt{by\_name\_not\_assigned.p}}}
\lstinputlisting[language=pascal]{lab4/test/by_name_not_assigned.p}

\end{multicols}

\section{Sources}
Sources used:
\begin{itemize}
    \item The course book by M. Spivey
    \item The reccomended book by R. Bornat
    \item \url{https://en.wikipedia.org/wiki/Evaluation\_strategy} for general information about evaluation strategies.
    \item \url{https://en.wikipedia.org/wiki/Jensen\%27s\_Device} for a description of Jensen's device, and for a description of Knuth and Merner's general problem solver.
    \item \url{https://cseweb.ucsd.edu/~goguen/courses/230w02/GPS.html} for a fuller description of Knuth and Merner's general problem solver.
    \item \url{www.overleaf.com/learn/latex}, for general \LaTeX help
    \item \url{https://stackoverflow.com/questions/790932/how-to-wrap-text-in-latex-tables} for how to wrap text in \LaTeX  tables
\end{itemize}

\end{document}
